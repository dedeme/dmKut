// Copyright 03-Oct-2023 ºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Quotes server data MWATCH ("MarketWatch").

import "../qsv";
import "libmkt/qs";
import "libdm/ext";

// DIARY -----------------------------------------------------------------------

// \s -> [[s,f].],[s.]]
readDaily = \html -> {
  sys.throw("Not implemented");
};

// \-> [s, b] ([html|error, ok])
downloadDaily = \ -> {
  sys.throw("Not implemented");
};

// HISTORIC --------------------------------------------------------------------

// \s -> [[<quote>.],[s.]]
readHistoric = \html -> {
  // [s.] (quotes type file 'NICK.tb')
  Qs = [];
  // [s.]
  Errs = [];
  ixV = [0];
  ix2V = [0];

  // \-> [<quote>.]
  mkQs = \-> {
    Qs, ok = qs.fromStr(Qs.size(), Qs.join("\n"));
    if (ok) return Qs;
    Errs.push(Qs);
    return [];
  };

  // \s -> [[<quote>.], [s...]]
  retError = \err -> {
    Errs.push(err);
    return [mkQs(), Errs];
  };

  ixV! = str.index(html, '<tbody class="table__body row-hover">');
  if (ixV! == -1) return retError("Beginning of table not found");
  ixV! += 25;

  endTable = str.indexFrom(html, "</tbody>", ixV!);
  if (endTable == -1) return retError("End of table not found");

  while () {
    ixV! = str.indexFrom(html, "<tr ", ixV!);
    if (ixV! == -1 | ixV! > endTable) break;
    ixV! += 4;

    endRow = str.indexFrom(html, "</tr>", ixV!);
    if (endRow == -1) return retError("End of row not found");

    // DATE
    ixV! = str.indexFrom(html, 'y">', ixV!);
    if (ixV! == -1) {
      Errs.push("Beginning of field 'date' not found");
      ixV! = endRow;
      continue;
    }
    ixV! += 3;
    ix2V! = str.indexFrom(html, "<", ixV!);
    if (ix2V! == -1) {
      Errs.push("End of field 'date' not found");
      ixV! = endRow;
      continue;
    }
    dateOp = time.fromEn(str.trim(html[ixV!:ix2V!]), "/");
    if (!dateOp) {
      Errs.push("Bad date: " + html[ixV!:ix2V!]);
      continue;
    }
    date = time.toStr(dateOp!);

    // Euro lenght correction.
    euroCorr = -5;
    // OPEN
    ix2V! = str.indexFrom(html, "&#x20AC;", ixV!);
    ixV! = ix2V! == -1 ? str.indexFrom(html, "€", ixV!) + euroCorr : ix2V!;
    if (ixV! == -1) {
      Errs.push("Beginning of field 'open' not found");
      ixV! = endRow;
      continue;
    }
    ixV! += 8;
    ix2V! = str.indexFrom(html, "<", ixV!);
    if (ix2V! == -1) {
      Errs.push("End of field 'open' not found");
      ixV! = endRow;
      continue;
    }
    openOp = math.fromEn(str.trim(html[ixV!:ix2V!]));
    if (!openOp) {
      Errs.push("Bad open: " + html[ixV!:ix2V!]);
      continue;
    }
    open = math.ftos(openOp!);

    // MAX
    ix2V! = str.indexFrom(html, "&#x20AC;", ixV!);
    ixV! = ix2V! == -1 ? str.indexFrom(html, "€", ixV!) + euroCorr : ix2V!;
    if (ixV! == -1) {
      Errs.push("Beginning of field 'max' not found");
      ixV! = endRow;
      continue;
    }
    ixV! += 8;
    ix2V! = str.indexFrom(html, "<", ixV!);
    if (ix2V! == -1) {
      Errs.push("End of field 'max' not found");
      ixV! = endRow;
      continue;
    }
    maxOp = math.fromEn(str.trim(html[ixV!:ix2V!]));
    if (!maxOp) {
      Errs.push("Bad max: " + html[ixV!:ix2V!]);
      continue;
    }
    max = math.ftos(maxOp!);

    // MIN
    ix2V! = str.indexFrom(html, "&#x20AC;", ixV!);
    ixV! = ix2V! == -1 ? str.indexFrom(html, "€", ixV!) + euroCorr : ix2V!;
    if (ixV! == -1) {
      Errs.push("Beginning of field 'min' not found");
      ixV! = endRow;
      continue;
    }
    ixV! += 8;
    ix2V! = str.indexFrom(html, "<", ixV!);
    if (ix2V! == -1) {
      Errs.push("End of field 'min' not found");
      ixV! = endRow;
      continue;
    }
    minOp = math.fromEn(str.trim(html[ixV!:ix2V!]));
    if (!minOp) {
      Errs.push("Bad min: " + html[ixV!:ix2V!]);
      continue;
    }
    min = math.ftos(minOp!);

    // CLOSE
    ix2V! = str.indexFrom(html, "&#x20AC;", ixV!);
    ixV! = ix2V! == -1 ? str.indexFrom(html, "€", ixV!) + euroCorr : ix2V!;
    if (ixV! == -1) {
      Errs.push("Beginning of field 'close' not found");
      ixV! = endRow;
      continue;
    }
    ixV! += 8;
    ix2V! = str.indexFrom(html, "<", ixV!);
    if (ix2V! == -1) {
      Errs.push("End of field 'close' not found");
      ixV! = endRow;
      continue;
    }
    closeOp = math.fromEn(str.trim(html[ixV!:ix2V!]));
    if (!closeOp) {
      Errs.push("Bad close: " + html[ixV!:ix2V!]);
      continue;
    }
    close = math.ftos(closeOp!);

    // VOL
    ixV! = str.indexFrom(html, 't">', ixV!);
    if (ixV! == -1) {
      Errs.push("Beginning of field 'vol' not found");
      ixV! = endRow;
      continue;
    }
    ixV! += 3;
    ix2V! = str.indexFrom(html, "<", ixV!);
    if (ix2V! == -1) {
      Errs.push("End of field 'vol' not found");
      ixV! = endRow;
      continue;
    }
    volOp = math.fromEn(html[ixV!:ix2V!]);
    if (!volOp) {
      Errs.push("Bad vol: " + html[ixV!:ix2V!]);
      continue;
    }
    vol = volOp!;

    // END
    Qs.push(str.fmt(
      "%v:%v:%v:%v:%v:%v:false",
      [date, open, close, max, min, vol]
    ));
    ixV! = endRow;
  }

  return [mkQs(), Errs];
};

/// \s -> [s|s, b] ([html|error, ok])
downloadHistoric = \code -> {
  url = str.fmt(
    "https://www.marketwatch.com/investing/stock/%v/download-data?countrycode=es&mod=mw_quote_tab",
    [code]
  );
  return ext.wdriver(url, 2);
};

// OTHER -----------------------------------------------------------------------

id = "MWATCH";

name = "MarketWatch";

withDiary = false;

// \ -> [[s,f].],[s.]]
freadDaily = \ -> {
  html, ok = downloadDaily();
  if (!ok) return [[], ["Fail reading daily web page of " + id + "\n" + html]];
  return readDaily(html);
};

withHistoric = true;

// \s -> [[<quote>.],[s.]]
freadHistoric = \code -> {
  html, ok = downloadHistoric(code);
  if (!ok) return [
    [],
    ["Fail reading historic web page of " + id + "-" + code + "\n" + html]
  ];
  return readHistoric(html);
};

/// Constructor.
/// \-> <qsv>
new = \-> return qsv.new(
    id, name, withDiary, freadDaily, withHistoric, freadHistoric
  );;
