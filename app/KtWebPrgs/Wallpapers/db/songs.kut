// Copyright 28-Sep-2023 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Songs data base.

import "data/cts";
import "data/song";
import "data/sighter";

dirV = [""];

// \s -> s
fpath = \group -> return path.cat([dirV!, "songs_" + group + ".db"]);;

/// Initialize data base
init = \parentDir -> dirV! = parentDir;;

///Returns groups list
/// \ -> [s.]
getGroups = \ -> {
  Groups = arr.filter(
    file.dir(cts.songsPath),
    \f -> return file.isDirectory(path.cat([cts.songsPath, f]));
  );
  if (!Groups) sys.throw("Song groups not found");
  return Groups;
};

/// \s -> ()
update = \group -> {
	p = fpath(group);
	if (!file.exists(p)) write(group, []);

  OldSongs = arr.map(js.r(file.read(p)), song.fromJs);
  NewSongs = []; // [<song>.]
  saveV = [false];
  for (songId = readSongsList(group)) {
    songOp = arr.find(OldSongs, \s -> return s.id == songId;);
    if (!songOp) {
      arr.push(NewSongs, song.mk(songId));
      saveV! = true;
    } else {
      arr.push(NewSongs, songOp!);
    }
  }
  if (saveV! | arr.size(NewSongs) != arr.size(OldSongs))
    write(group, NewSongs);

};

/// \s -> [s.]
readSongsList = \group -> {
  Songs = arr.filter(
    file.dir(path.cat([cts.songsPath, group])),
    \f -> return str.ends(f, ".mp3");
  );
  if (!Songs) sys.throw("No song found in group " + path.cat([cts.songsPath, group]));
  return Songs;
};

/// Returns songs ([<song>.]) of a group serialized with JSON.
/// \s -> s
readJs = \group -> return file.read(fpath(group));;

/// Returns group song.
/// \s -> [<song.>]
read = \group -> return arr.map(js.r(readJs(group)), song.fromJs);;

/// Write song.
/// \s, [<song>.] -> ()
write = \group, songs ->
  file.write(fpath(group), js.w(arr.map(songs, song.toJs)));;

/// Set level of song 'group'-'id'.
/// \s, s, i -> ()
setLevel = \group, id, level -> {
  Songs = read(group);
  for (S = Songs) if (S.id == id) S.level = level;
  write(group, Songs);
};

/// Set lapse of song 'group'-'id'.
/// \s, s, i -> ()
setLapse = \group, id, lapse -> {
  Songs = read(group);
  for (S = Songs) if (S.id == id) S.lapse = lapse;
  write(group, Songs);
};

/// Returns the next song
/// \ -> {s, <song>} :: {group, s}
next = \ -> {
  // NOTE: sighter,ext returns {s, <sighter>} :: {group, s}
  return sighter.next(
    getGroups,
    \group -> return read(group);,
    \group, Sighters -> write(group, Sighters);
  );
};
