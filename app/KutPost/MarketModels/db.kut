// Copyright 22-Mar-2024 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Data base management.

import "libdm/log";
import "libmkt/models";
import "libmkt/model";
import "data/vals";
import "data/ival";
import "cts";
import "fns";
import "updater";

/// Initializes data base.
/// NOTE: For add new models use commented code and calling 'MarketModels init'.
/// \ -> ()
init = \ -> {
  if (!file.exists(cts.dataPath)) {
    file.mkdir(cts.resultsDir);
    file.write(path.cat([cts.dataPath, "version.txt"]), cts.dataVersion);
    for (:model md = models.list()) {
      mdPath = path.cat([cts.resultsDir, md.id]);
      for (pr = cts.Periods)
        for (tp = cts.Types)
          file.mkdir(path.cat([mdPath, pr, tp]));
    }
    log.reset();
    return;
  }

//  mdPath = path.cat([cts.resultsDir, "MODEL-ID"]);
//  for (pr = cts.Periods)
//    for (tp = ["prices", "refs"])
//      file.mkdir(path.cat([mdPath, pr, tp]));

  sys.throw("Data base already initialized");
};

/// Returns dates for ranking.
/// \s -> [s.]
rankDates = \period -> {
  BaseDates = file.dir(path.cat(
    [cts.resultsDir, cts.modelBase, period, "prices"]
  ));
  arr.sort(BaseDates, \d1, d2 -> return d1 > d2;);
  return arr.take(BaseDates, cts.globalRanks);
};

/// Returns normalized results of a directory.
/// If results can not be read, returns 'r.date = ""' and  'r.Vals = []'
///   mdId  : Model identifier.
///   period: One of 'cts.Periods' (diary, weekly or monthly).
///   type  : One of 'cts.Types' (prices, accs or refs).
///   start : Index of the first date to return values.
///   len   : Number of dates to return values. NOTE: It can be returned less
///           values if there is some error.
/// \s, s, s, i, i -> <vals>
readResults = \mdId, period, type, start, len -> {
  :arr BaseDates = file.dir(path.cat(
    [cts.resultsDir, cts.modelBase, period, type]
  ));
  if (BaseDates.size() <= start) return vals.new("", []);

  BaseDates.sort(\d1, d2 -> return d1 > d2;);
  RqDates = BaseDates[start:start + len];

  dir = path.cat([cts.resultsDir, mdId, period, type]);

  date = RqDates[0];
  if (!file.exists(path.cat([dir, date]))) return vals.new("", []);
  Vals = [];
  Errs = [];
  for (d = RqDates) {
    fpath = path.cat([dir, d]);
    if (file.exists(fpath))
      Vals.push(arr.map(js.ra(file.read(fpath)), js.ri));
    else {
      if (d > "20240219" | mdId[:2] != "SS")
        Errs.push("Date missing " + d);
    }
  }

  if (!!Errs) {
    log.error(
      "Reading results of " + mdId + "-" + period + "-" + type + ":\n" +
      arr.join(Errs.map(\e -> return "  - " + e;), "\n")
    );
  }
  return vals.new(date, Vals);
};

/// Returns best value for global ranking.
/// When 'stats=="deviation"' 'r.ix == 0', because r.val is an average.
/// If the function fails, returns [].
///   mdId  : Model identifier.
///   period: One of 'cts.Periods' (diary, weekly or monthly).
///   type  : One of 'cts.Types' (prices, accs or refs).
///   idate : date index (first is 0).
///   stats : One of 'cts.Stats' (price, average, crrAverage, deviation).
/// \s, s, s, i, s -> [<ival>]
rankValue = \mdId, period, type, idate, stats -> {
  len = stats == "price" ? 1 : cts.statDates;
  :vals rs = readResults(mdId, period, type, idate, len);
  :arr Vals = rs.Vals;
  if (!Vals) return [];

  if (stats == "deviation") {
    Vs = fns.stats("deviation", Vals);
    sumV = [0];
    nV = [0];
    for (v = Vs) {
      if (v >= 0) {
      sumV! += v;
      nV! += 1;
    }}
    return [ival.new(0, sumV! / nV!)];
  }
  Vs = stats == "price" ? Vals[0] : fns.stats(stats, Vals);
  invV = [0];
  valV = [Vs[0]];
  for (i, v = Vs) if (v > valV!) {
    invV! = i;
    valV! = v;
  }
  return [ival.new(invV!, valV!)];
};

/// Updates data base.
///   mdId: Model intentifier.
///   date: Last date of data.
///   Prices: Assets by prices.
///   Accs  : Assets by accounting.
///   Refs  : Assets by references.
/// \s, s, [i.], [i.], [i.] -> ()
update = \mdId, date, Prices, Accs, Refs -> {
  weekInYear = \d -> {
    :time tm = time.fromStr(d)!;
    day1 = time.newDate(1, 1, tm.year());
    wdEn = time.weekday(day1);
    wd = wdEn == 0 ? 6 : wdEn - 1;
    dfDays = tm.dfDays(day1);
    return (dfDays + wd) / 7;
  };

  modelPath = path.cat([cts.resultsDir, mdId]);
  for (tp = cts.Types) {
    data = js.w(switch (tp) {
      "prices": Prices;
      "accs": Accs;
      default: Refs;
    });
    file.write(path.cat([modelPath, cts.Periods[0], tp, date]), data);

    wPath = path.cat([modelPath, cts.Periods[1], tp]);
    :arr Wdates = file.dir(wPath);
    if (!Wdates) {
      file.write(path.cat([wPath, date]), data);
    } else {
      Wdates.sort(\d1, d2 -> return d1 < d2;);
      lastDate = Wdates.peek();
      if (lastDate == date | weekInYear(lastDate) != weekInYear(date))
        file.write(path.cat([wPath, date]), data);
    }

    mPath = path.cat([modelPath, cts.Periods[2], tp]);
    :arr Mdates = file.dir(mPath);
    if (!Mdates) {
      file.write(path.cat([mPath, date]), data);
    } else {
      Mdates.sort(\d1, d2 -> return d1 < d2;);
      lastDate = Mdates.peek();
      if (lastDate == date | lastDate[:6] != date[:6])
        file.write(path.cat([mPath, date]), data);
    }
  }
};
