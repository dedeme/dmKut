// Copyright 06-Jan-2023 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Memory node of a player.

import "data/board";

/// Maximum value for fields evalW and evalL
maxEval = 1_000_000_000_000_000;

/// Result win
/// i
win = 0;
/// Result lost
/// i
lost = 1;
/// Result draw
/// i
draw = 2;

/// Constructor.
/// \[<node>]|[], i, i, i, [<node>, ...] -> <node>
new = \parent, move, evalW, evalL, children ->
  return [parent, move, evalW, evalL, children];;

/// Creates a "me" start node.
/// \-> <node>
mkStartMe = \-> {
    R = new([], 0, 0, 0, []);
    Children = children(R);
    for (i = 0:7)
      arr.push(Children, new([R], i, 1, 1, []));
    return R;
};

/// Creates a "other" start node.
/// \-> <node>
mkStartOther = \-> return new([], 0, 0, 0, []);;

/// Creates an empty, black, no-start, node and add it to 'parent'.
/// \<board>, <node>, i -> <node>
mk = \B, parent, mov -> {
    R = new([parent], mov, -1, -1, []);
    arr.push(children(parent), R);
    Children = children(R);
    for (c, i = str.split(board.topRow(B), ""))
      if (c == " ") arr.push(Children, new([R], i, 1, 1, []));
    return R;
  };

/// Returns the field 'parent'
/// \<node> -> [<node>]|[]
parent = \N -> return N[0];;

/// Returns the field 'move' (movimiento)
/// \<node> -> b
move = \N -> return N[1];;

/// Returns the field 'evalW' (counter of won matches)
/// \<node> -> i
evalW = \N -> return N[2];;

/// Returns the field 'evalL' (counter of lost matches)
/// \<node> -> i
evalL = \N -> return N[3];;

/// Returns the field 'childs'
/// \<node> -> [<node>, ...]
children = \N -> return N[4];;

// Auxiliar function for updateEval
// \<node> -> ()
simplify = \N -> {
  N[2] /= 1000000;
  N[3] /= 1000000;
  if (N[2] < 1) N[2] = 1;
  if (N[3] < 1) N[3] = 1;
};
/// Updates node evaluation.
///   N: Node to modify.
///   result: If the result which triger evaluation is 'win', 'lost' or 'draw'.
///   value: Point to add.
/// \\<node>, i , i -> ()
updateEval = \N, result, value ->
    if (result == win) {
      N[2] += value;
      if (N[2] > maxEval) simplify(N);
    } else if (result == lost) {
      N[3] += value;
      if (N[3] > maxEval) simplify(N);
    } else {
      N[2] += value;
      N[3] += value;
      if (N[2] > maxEval | N[3] > maxEval) simplify(N);
    }
  ;;

/// Returns the child with move 'move' or [] if it does not exist.
/// \<node>, i -> [<node>]|[]
child = \N, move -> return arr.find(children(N), \N2 -> return N2[1] == move;);;

/// Annotate a result from 'node'
///   N: Node to modify.
///   result: If the result which triger evaluation is 'win', 'lost' or 'draw'.
/// \<node> -> ()
annotateResult = \N, result -> {
  Value = [42];
  Node = [N];
  while (true) {
    if (arr.empty(Node![0])) break;
assert Node![1] != -1;
    updateEval(Node!, result, Value!);
    Value! -= 1;
    P = Node![0]!;
    if (arr.empty(P[0])) break;
    Node! = P[0]!;
  }
};

/// \<node> -> s
toJs = \N -> return js.wa([
    js.wi(N[1]),
    js.wi(N[2]),
    js.wi(N[3]),
    js.wa(arr.mp(N[4], toJs))
  ]);;

/// \s -> <node>
fromJs = \j -> {
  A = js.ra(j);
  childs = arr.mp(js.ra(A[3]), fromJs);
  R = new(
    [],
    js.ri(A[0]),
    js.ri(A[1]),
    js.ri(A[2]),
    childs
  );
  for (child = childs) child[0] = [R];
  return R;
};

