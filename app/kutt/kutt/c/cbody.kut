// Code generated by mkBuiltC.

/// Built-in C body.
/// s
code = """
  #include "built.h"

  //
  // thread.c ---------------------------------
  //
  // Copyright 21-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  static pthread_mutex_t thread_mutex;
  static pthread_t *thread_in = NULL;
  
  struct thread_Thread {
    void (*fn) (void *);
    void *value;
  };
  
  static struct thread_Thread *thread_thread_new (
    void (*fn) (void *), void *value
  ) {
    struct thread_Thread *this = MALLOC(struct thread_Thread);
    this->fn = fn;
    this->value = value;
    return this;
  }
  
  static void *thread_thread_run (struct thread_Thread *data) {
    exc_thread_init();
    data->fn(data->value);
    exc_thread_end();
    return NULL;
  }
  
  static void *thread_thread_run0 (void (*fn)(void)) {
    exc_thread_init();
    fn();
    exc_thread_end();
    return NULL;
  }
  
  pthread_t *thread_start (void (*fn)(void)) {
    pthread_t *thr = MALLOC(pthread_t);
    int err = pthread_create(thr, NULL, (void *(*)(void *))thread_thread_run0, fn);
    if (err != 0)
      EXC_GENERIC(str_f("Fail starting thread: %s", strerror(err)));
    return thr;
  }
  
  pthread_t *thread_start2 (void (*fn)(void *), void *value) {
    pthread_t *thr = MALLOC(pthread_t);
    struct thread_Thread *data = thread_thread_new(fn, value);
    int err = pthread_create(thr, NULL, (void *(*)(void *))thread_thread_run, data);
    if (err != 0)
      EXC_GENERIC(str_f("Fail starting thread: %s", strerror(err)));
    return thr;
  }
  
  void thread_run (void (*fn)(void)) {
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  
    pthread_t *thr = MALLOC(pthread_t);
    int err = pthread_create(thr, &attr, (void *(*)(void *))thread_thread_run0, fn);
    if (err != 0)
      EXC_GENERIC(str_f("Fail running thread: %s", strerror(err)));
  }
  
  void thread_run2 (void (*fn)(void *), void *value) {
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  
    pthread_t *thr = MALLOC(pthread_t);
    struct thread_Thread *data = thread_thread_new(fn, value);
    int err = pthread_create(thr, &attr, (void *(*)(void *))thread_thread_run, data);
    if (err != 0)
      EXC_GENERIC(str_f("Fail running thread: %s", strerror(err)));
  }
  
  void thread_join (pthread_t *thr) {
    pthread_join(*thr, NULL);
  }
  
  void thread_sync (void (*fn)(void)) {
    pthread_t self = pthread_self();
    if (thread_in && pthread_equal(self, *thread_in)) {
      fn();
      return;
    }
  
    pthread_mutex_lock(&thread_mutex);
    thread_in = MALLOC(pthread_t);
    *thread_in = self;
    fn();
    thread_in = NULL;
    pthread_mutex_unlock(&thread_mutex);
  }
  
  void thread_sync2 (void (*fn)(void *), void *value) {
    pthread_t self = pthread_self();
    if (thread_in && pthread_equal(self, *thread_in)) {
      fn(value);
      return;
    }
  
    pthread_mutex_lock(&thread_mutex);
    thread_in = MALLOC(pthread_t);
    *thread_in = self;
    fn(value);
    thread_in = NULL;
    pthread_mutex_unlock(&thread_mutex);
  }
  
  //
  // opt.c ---------------------------------
  //
  // Copyright 21-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct opt_Opt {
    void *value;
  };
  
  Opt *opt_some (void *value) {
    Opt *this = MALLOC(Opt);
    this->value = value;
    return this;
  }
  
  Opt *opt_none (void) {
    Opt *this = MALLOC(Opt);
    this->value = NULL;
    return this;
  }
  
  void *opt_get (Opt *this) {
    return this->value;
  }
  
  void *opt_eget (Opt *this) {
    if (!this->value)
      EXC_ILLEGAL_STATE("Option is null");
  
    return this->value;
  }
  
  char *opt_to_js (Opt *this, char *(*to)(void *e)) {
    if (this->value) return to(this->value);
    return js_wn();
  }
  
  
  Opt *opt_from_js (char *js, void *(*from)(char *jse)) {
    if (js_is_null(js)) return opt_none();
    return opt_some(from(js));
  }
  
  //
  // arr.c ---------------------------------
  //
  // Copyright 20-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct arr_Arr {
    void **es; // Start elements.
    void **end; //End elements. (Elements are between 'es' (inclusive) and 'end'
               // exclusive.
    void **endbf; // End buffer.
  };
  
  Arr *arr_new (void) {
    return arr_new_bf(15);
  }
  
  Arr *arr_new_bf (int buffer) {
    if (buffer < 1) buffer = 1;
    Arr *this = MALLOC(Arr);
    void **es = GC_MALLOC(buffer * sizeof(void *));
    this->es = es;
    this->end = es;
    this->endbf = es + buffer;
    return this;
  }
  
  Arr *arr_new_fill (void *e, int size) {
    int bf_size = size < 15 ? 15 : size;
    Arr *this = MALLOC(Arr);
    void **es = GC_MALLOC(bf_size * sizeof(void *));
    void **end = es + size;
    this->es = es;
    this->end = end;
    this->endbf = es + bf_size;
    void **p = es;
    while (p < end) *p++ = e;
    return this;
  }
  
  Arr *arr_new_from (void *e, ...) {
    va_list args;
    void *tmp;
  
    Arr *this = arr_new();
    arr_push(this, e);
  
    va_start(args, e);
    tmp = va_arg(args, void *);
    while (tmp) {
      arr_push(this, tmp);
      tmp = va_arg(args, void *);
    }
    va_end(args);
  
    return this;
  }
  
  Arr *arr_new_c (int size, void **es) {
    int bf_size = size < 15 ? 15 : size;
  
    Arr *this = MALLOC(Arr);
    this->es = GC_MALLOC(bf_size * sizeof(void *));
    this->end = this->es + size;
    this->endbf = this->es + bf_size;
    memcpy(this->es, es, size * sizeof(void *));
    return this;
  }
  
  Arr *arr_copy (Arr *this) {
    int buffer = this->endbf - this->es;
    int bf_size = buffer * sizeof(void *);
    Arr *r = MALLOC(Arr);
    void **es = GC_MALLOC(bf_size);
    r->es = es;
    r->end = es + (this->end - this->es);
    r->endbf = es + buffer;
    memcpy(es, this->es, bf_size);
    return r;
  }
  
  void **arr_begin (Arr *this) {
    return this->es;
  }
  
  void **arr_end (Arr *this) {
    return this->end;
  }
  
  int arr_size (Arr *this) {
    return this->end - this->es;
  }
  
  int arr_empty (Arr *this) {
    return this->es == this->end;
  }
  
  void *arr_get (Arr *this, int ix) {
    EXC_RANGE(ix, 0, arr_size(this) - 1);
    return *(this->es + ix);
  }
  
  void arr_push (Arr *this, void *e) {
    if (this->end == this->endbf) {
      int size = this->endbf - this->es;
      int new_size = size + size;
      this->es = GC_REALLOC(this->es, new_size * sizeof(void *));
      this->end = this->es + size;
      this->endbf = this->es + new_size;
    }
    *this->end++ = e;
  }
  
  void *arr_pop (Arr *this) {
    if (this->es >= this->end)
      EXC_ILLEGAL_STATE("Array is empty");
  
    --this->end;
    return *this->end;
  }
  
  void *arr_peek (Arr *this) {
    if (this->es >= this->end)
      EXC_ILLEGAL_STATE("Array is empty");
  
    return *(this->end - 1);
  }
  
  void arr_set (Arr *this, int ix, void *e) {
    EXC_RANGE(ix, 0, arr_size(this) - 1);
  
    void **p = this->es + ix;
    *p = e;
  }
  
  void arr_insert (Arr *this, int ix, void *e) {
    EXC_RANGE(ix, 0, arr_size(this));
  
    arr_push(this, e);
    void **p = this->end - 1;
    void **pix = this->es + ix;
    while (p > pix) {
      *p = *(p - 1);
      --p;
    }
    *p = e;
  }
  
  void arr_remove (Arr *this, int ix) {
    EXC_RANGE(ix, 0, arr_size(this) - 1);
  
    void **p = this->es + ix;
    void **p1 = p + 1;
    void **pend = this->end;
    while (p1 < pend) {
      *p++ = *p1++;
    }
    --this->end;
  }
  
  void arr_cat (Arr *this, Arr *other) {
    int other_len = other->end - other->es;
    if (other_len) {
      int this_len = this->end - this->es;
      int this_size = this->endbf - this->es;
      if (this_len + other_len >= this_size){
        int new_size = this_size + other_len;
        this->es = GC_REALLOC(this->es, new_size * sizeof(void *));
        this->end = this->es + this_len;
        this->endbf = this->es + new_size;
      }
      void **s = other->es;
      void **t = this->end;
      while (s < other->end) *t++ = *s++;
      this->end = t;
    }
  }
  
  void arr_set_arr (Arr *this, int ix, Arr *other) {
    arr_set_range(this, ix, other, 0, arr_size(other));
  }
  
  void arr_set_range (Arr *this, int ix, Arr *other, int begin, int end) {
    if (end < begin)
      EXC_ILLEGAL_ARGUMENT(
        "end < begin", str_f("end >= %d", begin), str_f("end == %d", end)
      );
    int size = end - begin;
    if (!size) return;
    EXC_RANGE(begin, 0, arr_size(other) - size);
    EXC_RANGE(ix, 0, arr_size(this) - size);
    void **target = this->es + ix;
    void **source = other->es + begin;
    memcpy(target, source, sizeof(void *) * size);
  }
  
  void arr_insert_arr (Arr *this, int ix, Arr *other) {
    return arr_insert_range(this, ix, other, 0, arr_size(other));
  }
  
  void arr_insert_range (Arr *this, int ix, Arr *other, int begin, int end) {
    if (end < begin)
      EXC_ILLEGAL_ARGUMENT(
        "end < begin", str_f("end >= %d", begin), str_f("end == %d", end)
      );
    int other_len = end - begin;
    if (!other_len) return;
  
    int this_len = this->end - this->es;
    EXC_RANGE(begin, 0, arr_size(other) - other_len);
    EXC_RANGE(ix, 0, this_len);
  
    int new_len = this_len + other_len;
    int new_size = new_len + 15;
    void **new_es = GC_MALLOC(new_size * sizeof(void *));
    memcpy(new_es, this->es, sizeof(void *) * ix);
    memcpy(new_es + ix, other->es + begin, sizeof(void *) * other_len);
    memcpy(
      new_es + (ix + other_len),
      this->es + ix,
      sizeof(void *) * ((this->end - this->es) - ix)
    );
    this->es = new_es;
    this->end = new_es + new_len;
    this->endbf = new_es + new_size;
  }
  
  void arr_remove_range (Arr *this, int begin, int end) {
    int sz = arr_size(this);
    EXC_RANGE(end, 0, sz);
    EXC_RANGE(begin, 0, end);
  
    int df = end - begin;
    if (df == 0) {
      return;
    }
  
    void **pb = this->es + begin;
    void **pe = this->es + end;
    void **pend = this->end;
    while (pe < pend) {
      *pb++ = *pe++;
    }
    this->end -= df;
  }
  
  void arr_clear (Arr *this) {
    this->end = this->es;
  }
  
  void arr_reverse (Arr *this) {
    void **p = this->es;
    void **end = this->end - 1;
    void *tmp;
    for (int i = 0; i < (this->end - this->es) / 2; ++i) {
      tmp = *p;
      *p++ = *end;
      *end-- = tmp;
    }
  }
  
  void arr_sort (Arr *this, int (*greater)(void *, void *)) {
    void sort(void **a, int size) {
      if (size < 2) {
        return;
      }
      if (size == 2) {
        if (greater(a[0], a[1])) { void *tmp = a[0]; a[0] = a[1]; a[1] = tmp; }
        return;
      }
      if (size == 3) {
        if (greater(a[0], a[1])) { void *tmp = a[0]; a[0] = a[1]; a[1] = tmp; }
        if (greater(a[0], a[2])) { void *tmp = a[0]; a[0] = a[2]; a[2] = tmp; }
        if (greater(a[1], a[2])) { void *tmp = a[1]; a[1] = a[2]; a[2] = tmp; }
      }
      int mid1 = size >> 1;
      int mid2 = size - mid1;
      void *a1[mid1];
      void *a2[mid2];
      void **pa = a;
      void **pa1 = a1;
      void **pa2 = a2;
      for (int i = 0; i < mid1; ++i) *pa1++ = *pa++;
      for (int i = 0; i < mid2; ++i) *pa2++ = *pa++;
      sort(a1, mid1);
      sort(a2, mid2);
  
      pa = a;
      pa1 = a1;
      void **pa1_end = a1 + mid1;
      pa2 = a2;
      void **pa2_end = a2 + mid2;
  
      for(;;) {
        if (pa1 == pa1_end) {
          while (pa2 < pa2_end) *pa++ = *pa2++;
          break;
        }
        if (pa2 == pa2_end) {
          while (pa1 < pa1_end) *pa++ = *pa1++;
          break;
        }
        if (greater(*pa1, *pa2)) *pa++ = *pa2++;
        else *pa++ = *pa1++;
      }
    }
  
    sort(this->es, this->end - this->es);
  }
  
  void arr_shuffle (Arr *this) {
    int rnd_i (int max) {
      return (int)(((double)rand() / (double)RAND_MAX) * max);
    }
    void **es = this->es;
    int size = this->end - es;
    void **p = this->end - 1;
    void **pix, *tmp;
    while (p > es) {
      pix = es + rnd_i(size--);
      tmp = *p;
      *p-- = *pix;
      *pix = tmp;
    }
  }
  
  int arr_all (Arr *this, int (*pred)(void *e)) {
    void **p = this->es;
    while (p < this->end) if (!pred(*p++)) return 0;
    return 1;
  }
  
  int arr_any (Arr *this, int (*pred)(void *e)) {
    void **p = this->es;
    while (p < this->end) if (pred(*p++)) return 1;
    return 0;
  }
  
  void arr_each(Arr *this, void (*fn)(void *e)) {
    void **p = this->es;
    while (p < this->end) fn(*p++);
  }
  
  void arr_each_ix(Arr *this, void (*fn)(void *e, int ix)) {
    void **p = this->es;
    int ix = 0;
    while (p < this->end) fn(*p++, ix++);
  }
  
  int arr_eq(Arr *a1, Arr *a2, int (*feq)(void *e1, void *e2)) {
    if (arr_size(a1) != arr_size(a2)) return FALSE;
    void **p1 = a1->es;
    void **p2 = a2->es;
    while (p1 < a1->end) if (!feq(*p1++, *p2++)) return FALSE;
    return TRUE;
  }
  
  int arr_index (Arr *this, int (*pred)(void *e)) {
    void **es = this->es;
    void **p = es;
    while (p < this->end) if (pred(*p++)) return p - es - 1;
    return -1;
  }
  
  Opt *arr_find(Arr *this, int (*pred)(void *e)) {
    void **p = this->es;
    while (p < this->end) {
      void *e = *p++;
      if (pred(e)) return opt_some(e);
    }
    return opt_none();
  }
  
  Opt *arr_find_last(Arr *this, int (*pred)(void *e)) {
    Opt *r = opt_none();
    void **p = this->es;
    while (p < this->end) {
      void *e = *p++;
      if (pred(e)) r = opt_some(e);
    }
    return r;
  }
  
  int arr_last_index (Arr *this, int (*pred)(void *e)) {
    void **es = this->es;
    void **p = this->end;
    if (p > es) {
      while (--p > es) if (pred(*p)) return p - es;
      if (pred(*es)) return 0;
    }
    return -1;
  }
  
  void arr_filter_in (Arr *this, int (*pred)(void *e)) {
    void **p = this->es;
    void **end = this->end;
    void **new_end = p;
    while (p < end) {
      if (pred(*p)) {
        *new_end++ = *p;
      }
      ++p;
    }
    this->end = new_end;
  }
  
  Arr *arr_take (Arr *this, int n) {
    if (n > arr_size(this)) return arr_copy(this);
    Arr *r = arr_new();
    void **p = this->es;
    for (int i = 0; i < n; ++i) arr_push(r, *p++);
    return r;
  }
  
  Arr *arr_takef (Arr *this, int (*predicate)(void *e)) {
    Arr *r = arr_new();
    void **p = this->es;
    while (p < this->end) {
      if (predicate(*p)) arr_push(r, *p);
      else break;
      ++p;
    }
    return r;
  }
  
  Arr *arr_drop (Arr *this, int n) {
    if (n < 0) return arr_copy(this);
    if (n >= arr_size(this)) return arr_new();
    Arr *r = arr_new();
    void **p = this->es + n;
    while (p < this->end) arr_push(r, *p++);
    return r;
  }
  
  Arr *arr_dropf (Arr *this, int (*predicate)(void *e)) {
    Arr *r = arr_new();
    void **p = this->es;
    while (p < this->end) {
      if (!predicate(*p)) break;
      ++p;
    }
    while (p < this->end) arr_push(r, *p++);
    return r;
  }
  
  Arr *arr_filter_to (Arr *this, int (*predicate)(void *e)) {
    Arr *r = arr_new();
    void **p = this->es;
    while (p < this->end) {
      void *e = *p++;
      if (predicate(e)) arr_push(r, e);
    }
    return r;
  }
  
  Arr *arr_map (Arr *this, void *(*converter)(void *e)) {
    Arr *r = arr_new();
    void **p = this->es;
    while (p < this->end) arr_push(r, converter(*p++));
    return r;
  }
  
  Arr *arr_map2 (Arr *this, void *(*conv1)(void *e), void *(*conv2)(void *e)) {
    Arr *r = arr_new();
    void **p = this->es;
    void **end = this->end;
    if (p < end) arr_push(r, conv1(*p++));
    while (p < end) arr_push(r, conv2(*p++));
    return r;
  }
  
  void *arr_reduce(Arr *this, void *seed, void *(*fn)(void *seed, void *elem)) {
    void **p = this->es;
    while (p < this->end) seed = fn(seed, *p++);
    return seed;
  }
  
  Arr *arr_zip (Arr *a1, Arr *a2, void *(*converter)(void *e1, void *e2)) {
    Arr *r = arr_new();
    void **p1 = a1->es;
    void **p2 = a2->es;
    while (p1 < a1->end && p2 < a2->end) arr_push(r, converter(*p1++, *p2++));
    return r;
  }
  
  Arr *arr_zip3 (
    Arr *a1, Arr *a2, Arr *a3, void*(*converter)(void*e1, void*e2, void*e3)
  ) {
    Arr *r = arr_new();
    void **p1 = a1->es;
    void **p2 = a2->es;
    void **p3 = a3->es;
    while (p1 < a1->end && p2 < a2->end && p3 < a3->end)
      arr_push(r, converter(*p1++, *p2++, *p3++));
    return r;
  }
  
  Arr *arr_duplicates (Arr *this, int (feq)(void *e1, void *e2)) {
    Arr *r = arr_new();
    Arr *new = arr_new();
    void **p = this->es;
    while (p < this->end) {
      void *e = *p++;
      int unique = 1;
      void **newp = new->es;
      while (newp < new->end) {
        void *newe = *newp++;
        if (feq(e, newe)) {
          int rnew = 1;
          void **rp = r->es;
          while (rp < r->end) {
            void *re = *rp++;
            if (feq(e, re)) {
              rnew = 0;
              break;
            }
          }
          if (rnew) {
            arr_push(r, e);
          }
          unique = 0;
          break;
        }
      }
      if (unique) {
        arr_push(new, e);
      }
    }
    this->es = new->es;
    this->end = new->end;
    this->endbf = new->endbf;
  
    return r;
  }
  
  // a is Arr<char>
  char *arr_cjoin(Arr *a, char sep) {
    Buf *bf = buf_new();
    int first = 1;
    char **p = (char **)a->es;
    while (p < (char **)a->end) {
      if (first) {
        first = 0;
      } else {
        buf_cadd(bf, sep);
      }
      buf_add(bf, *p++);
    }
    return str_new(buf_str(bf));
  }
  
  // a is Arr<char>
  char *arr_join(Arr *a, char *sep) {
    Buf *bf = buf_new();
    int first = 1;
    char **p = (char **)a->es;
    while (p < (char **)a->end) {
      if (first) {
        first = 0;
      } else {
        buf_add(bf, sep);
      }
      buf_add(bf, *p++);
    }
    return str_new(buf_str(bf));
  }
  
  // -------------------------------------------------------------------------- //
  typedef struct {                                                              //
    void **es;                                                                  //
    size_t n;                                                                   //
    size_t i;                                                                   //
  } arr_to_it_O;                                                                //
  static Opt *to_it_next(arr_to_it_O *o) {                                      //
    size_t i = o->i;                                                            //
    if (i < o->n) {                                                             //
      o->i += 1;                                                                //
      return opt_some(o->es[i]);                                                //
    } else {                                                                    //
      return opt_none();                                                        //
    }                                                                           //
  }                                                                             //
  // -------------------------------------------------------------------------- //
  It *arr_to_it (Arr *this) {
    arr_to_it_O *o = MALLOC(arr_to_it_O);
    o->es = this->es;
    o->n = arr_size(this);
    o->i = 0;
    return it_new(o, (Opt *(*)(void*))to_it_next);
  }
  
  Arr *arr_from_it (It *it) {
    Arr *r = arr_new();
    while (it_has_next(it)) {
      arr_push(r, it_next(it));
    }
    return r;
  }
  
  char *arr_to_js (Arr *this, char *(*to)(void *e)) {
    return js_wa((Arr *)arr_map(this, (FMAP)to));
  }
  
  Arr *arr_from_js (char *js, void *(*from)(char *ejs)) {
    return arr_map(js_ra(js), (FMAP)from);
  }
  
  //
  // bytes.c ---------------------------------
  //
  // Copyright 16-Oct-2018 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct bytes_Bytes {
    unsigned char *bs;
    int length;
  };
  
  Bytes *bytes_new() {
    return bytes_new_bf(0);
  }
  
  Bytes *bytes_new_bf(int length) {
    Bytes *this = MALLOC(Bytes);
    this->bs = ATOMIC(length);
    this->length = length;
    return this;
  }
  
  Bytes *bytes_from_bytes(unsigned char *bs, int length) {
    Bytes *this = MALLOC(Bytes);
    this->bs = ATOMIC(length);
    memcpy(this->bs, bs, length);
    this->length = length;
    return this;
  }
  
  Bytes *bytes_from_str (char *s) {
    return bytes_from_bytes((unsigned char *)s, strlen(s));
  }
  
  unsigned char *bytes_bs(Bytes *this) {
    return this->bs;
  }
  
  int bytes_len(Bytes *this) {
    return this->length;
  }
  
  void bytes_add_bytes (Bytes *this, unsigned char *bs, int length) {
    int sum = this->length + length;
    if (sum) {
      this->bs = GC_REALLOC(this->bs, sum);
      memcpy(this->bs + this->length, bs, length);
      this->length = sum;
    }
  }
  
  void bytes_add (Bytes *this, Bytes *another) {
    bytes_add_bytes(this, another->bs, another->length);
  }
  
  void bytes_add_str (Bytes *this, char *s) {
    bytes_add_bytes(this, (unsigned char *)s, strlen(s));
  }
  
  char *bytes_to_str(Bytes *this) {
    int len = this->length;
    char *r = ATOMIC(len + 1);
    memcpy(r, this->bs, len);
    r[len] = 0;
    return r;
  }
  
  char *bytes_to_js(Bytes *this) {
    char *b64 = b64_encode_bytes(this);
    size_t len = strlen(b64);
    char *r = ATOMIC(len + 3);
    r[0] = '"';
    memcpy(r + 1, b64, len);
    r[len + 1] = '"';
    r[len + 2] = 0;
    return r;
  }
  
  Bytes *bytes_from_js(char *js) {
    size_t len = strlen(js) - 2;
    char *b64 = ATOMIC(len + 1);
    memcpy(b64, js + 1, len);
    b64[len] = 0;
  
    return b64_decode_bytes(b64);
  }
  
  //
  // b64.c ---------------------------------
  //
  // Copyright 22-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  static char encoding_table[] =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  static const unsigned char decoding_table[256] = {
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
  };
  static int mod_table[] = {0, 2, 1};
  
  static char *base64_encode(
    unsigned char *data,
    size_t input_length,
    size_t *output_length
  ) {
    *output_length = 4 * ((input_length + 2) / 3);
    char *encoded_data = ATOMIC(*output_length + 1);
  
    for (int i = 0, j = 0; i < input_length;) {
      uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;
      uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;
      uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;
  
      uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;
  
      encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];
      encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];
      encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];
      encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];
    }
  
    for (int i = 0; i < mod_table[input_length % 3]; i++) {
      encoded_data[*output_length - 1 - i] = '=';
    }
  
    *(encoded_data + *output_length) = 0;
    return encoded_data;
  }
  
  // Only for positive input_length
  static Bytes *base64_decode(
    const char *data,
    size_t input_length,
    size_t *output_length
  ) {
    if (input_length % 4 != 0)
      EXC_ILLEGAL_ARGUMENT(
        "Bad B64 string", "Length % 4 != 0", str_f("Length %ld", input_length)
      );
  
    *output_length = input_length / 4 * 3;
    if (data[input_length - 1] == '=') (*output_length)--;
    if (data[input_length - 2] == '=') (*output_length)--;
  
    Bytes *bs = bytes_new_bf(*output_length);
    unsigned char *decoded_data = bytes_bs(bs);
  
    for (int i = 0, j = 0; i < input_length;) {
      uint32_t sextet_a = data[i] == '='
        ? 0 & i++
        : decoding_table[(int)data[i++]];
      uint32_t sextet_b = data[i] == '='
        ? 0 & i++
        : decoding_table[(int)data[i++]];
      uint32_t sextet_c = data[i] == '='
        ? 0 & i++
        : decoding_table[(int)data[i++]];
      uint32_t sextet_d = data[i] == '='
        ? 0 & i++
        : decoding_table[(int)data[i++]];
  
      uint32_t triple = (sextet_a << 3 * 6) +
        (sextet_b << 2 * 6) +
        (sextet_c << 1 * 6) +
        (sextet_d << 0 * 6);
  
      if (j < *output_length) {
        decoded_data[j++] = (triple >> 2 * 8) & 0xFF;
      }
      if (j < *output_length) {
        decoded_data[j++] = (triple >> 1 * 8) & 0xFF;
      }
      if (j < *output_length) {
        decoded_data[j++] = (triple >> 0 * 8) & 0xFF;
      }
    }
    return bs;
  }
  
  char *b64_decode(char *b64) {
    Bytes *bs = b64_decode_bytes(b64);
    int len = bytes_len(bs);
    char *s = ATOMIC(len + 1);
    memcpy(s, bytes_bs(bs), len);
    *(s + len) = 0;
    if (str_runes_len(s) == -1)
      return arr_join(str_runes(s), "");
  
    return s;
  }
  
  Bytes *b64_decode_bytes(char *b64) {
    if (*b64) {
      size_t len;
      return base64_decode(b64, strlen(b64), &len);
    } else {
      return bytes_new_bf(0);
    }
  }
  
  char *b64_encode(char *s) {
    size_t len;
    return base64_encode((unsigned char *)s, strlen(s), &len);
  }
  
  char *b64_encode_bytes(Bytes *bs) {
    size_t len;
    return base64_encode(bytes_bs(bs), bytes_len(bs), &len);
  }
  
  //
  // buf.c ---------------------------------
  //
  // Copyright 21-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct buf_Buf{
    char *str; // String in course.
    int len; // Length of 'str'.
    int bf_size; // Buffer size.
  };
  
  Buf *buf_new(void) {
    return buf_new_bf(151);
  }
  
  Buf *buf_new_bf(int buffer_size) {
    Buf *this = MALLOC(Buf);
    this->bf_size = buffer_size - 1;
    this->str = ATOMIC(buffer_size);
    memset(this->str, 0, buffer_size);
    this->len = 0;
    return this;
  }
  
  char *buf_str (Buf *this) {
    return this->str;
  }
  
  int buf_len (Buf *this) {
    return this->len;
  }
  
  void buf_add_buf (Buf *this, char *data, int length) {
    int ixend = this->len + length;
    if (this->bf_size < ixend) {
        while (this->bf_size < ixend) {
            this->bf_size += this->bf_size;
        }
        int memsize = this->bf_size + 1;
        char *newstr = ATOMIC(memsize);
        memset(newstr, 0, memsize);
        memcpy(newstr, this->str, this->len);
        this->str = newstr;
    }
    memcpy(this->str + this->len, data, length);
    this->len = ixend;
  }
  
  void buf_add (Buf *this, char *data) {
    buf_add_buf(this, data, strlen(data));
  }
  
  void buf_cadd (Buf *this, char data) {
    buf_add_buf(this, &data, 1);
  }
  
  void buf_reset(Buf *this) {
    memset(this->str, 0, this->bf_size);
    this->len = 0;
  }
  
  
  //
  // cryp.c ---------------------------------
  //
  // Copyright 22-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  static char *b64_base =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  char *cryp_genk (int lg) {
    if (lg <= 0)
      EXC_ILLEGAL_ARGUMENT("Value out of range", "Value < 0", str_f("%d", lg));
  
    char *r = ATOMIC(lg + 1);
    char *p = r + lg;
    *p-- = 0;
    while (lg--) {
      *p-- = *(b64_base + sys_rnd_i(64));
    }
    return r;
  }
  
  char *cryp_key (char *key, int lg) {
    if (!*key)
      EXC_ILLEGAL_ARGUMENT("Wrong key", "Value != \"\"", "\"\"");
  
    char *k0 = str_f(
      "%scodified in irreversibleDeme is good, very good!\n\r8@@", key);
    char *b64 = b64_encode(k0);
    Bytes *k = b64_decode_bytes(b64);
  
    unsigned char *ka = bytes_bs(k);
    size_t lenk = bytes_len(k);
    unsigned char sum = 0;
    unsigned char *p = ka;
    for (int i = 0; i < lenk; ++i) sum += *p++;
  
    size_t lg2 = lg + lenk;
    Bytes *rbs = bytes_new_bf(lg2);
    unsigned char *ra = bytes_bs(rbs);
    Bytes *rbs1 = bytes_new_bf(lg2);
    unsigned char *ra1 = bytes_bs(rbs1);
    Bytes *rbs2 = bytes_new_bf(lg2);
    unsigned char *ra2 = bytes_bs(rbs2);
  
    size_t ik = 0;
    size_t v1, v2, v3, v4;
    for (size_t i = 0; i < lg2; ++i) {
      v1 = ka[ik];
      v2 = v1 + ka[v1 % lenk];
      v3 = v2 + ka[v2 % lenk];
      v4 = v3 + ka[v3 % lenk];
      sum = sum + i + v4;
      ra1[i] = sum;
      ra2[i] = sum;
      ++ik;
      if (ik == lenk) {
        ik = 0;
      }
    }
  
    for (size_t i = 0; i < lg2; ++i) {
      v1 = ra2[i];
      v2 = v1 + ra2[v1 % lg2];
      v3 = v2 + ra2[v2 % lg2];
      v4 = v3 + ra2[v3 % lg2];
      sum = sum + v4;
      ra2[i] = sum;
      ra[i] = sum + ra1[i];
    }
  
    return str_left(b64_encode_bytes(rbs), lg);
  }
  
  char *cryp_encode (char *k, char *s) {
    if (!*k)
      EXC_ILLEGAL_ARGUMENT("Wrong key", "Value != \"\"", "\"\"");
  
    char *b64 = b64_encode(s);
  
    size_t lg = strlen(b64);
    char *k2 = cryp_key(k, lg);
  
    Bytes *rbs = bytes_new_bf(lg);
  
    unsigned char *prbs = bytes_bs(rbs);
    unsigned char *pk2 = (unsigned char *)k2;
    unsigned char *pb64 = (unsigned char *)b64;
    for(int i = 0; i < lg; ++i) *prbs++ = (*pk2++) + (*pb64++);
  
    return b64_encode_bytes(rbs);
  }
  
  char *cryp_decode (char *k, char *c) {
    if (!*k)
      EXC_ILLEGAL_ARGUMENT("Wrong key", "Value != \"\"", "\"\"");
  
    Bytes *bs = b64_decode_bytes(c);
  
    size_t lg = bytes_len(bs);
    char *k2 = cryp_key(k, lg);
  
    char *b64 = ATOMIC(lg + 1);
  
    unsigned char *pbs = bytes_bs(bs);
    unsigned char *pk2 = (unsigned char *)k2;
    char *pb64 = b64;
    for(int i = 0; i < lg; ++i) *pb64++ = *pbs++ - *pk2++;
    *pb64 = 0;
  
    return b64_decode(b64);
  }
  
  //
  // exc.c ---------------------------------
  //
  // Copyright 21-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  
  // Arr[Exc]
  static Arr *pool = NULL;
  static pthread_mutex_t mutex;
  
  struct exc_Exc {
    pthread_t thread;
    // [jmp_buf]
    Arr *buf;
    char *type;
    char *msg;
    // [char]
    Arr *stack;
  };
  
  static Exc *exc_new (pthread_t thread, jmp_buf *bf) {
    Exc *this = MALLOC(Exc);
    this->thread = thread;
    this->buf = arr_new_from(bf, NULL);
    this->type = NULL;
    this->msg = NULL;
    this->stack = arr_new();
    return this;
  }
  
  char *exc_type (Exc *this) {
    if (!this->type) {
      puts("exc_type: 'type' is NULL");
      exit(1);
    }
    return this->type;
  }
  
  char *exc_msg (Exc *this) {
    if (!this->msg) {
      printf("exc_msg: 'msg' is NULL");
      exit(1);
    }
    return this->msg;
  }
  
  // Arr[char]
  Arr *exc_stack (Exc *this) {
    return this->stack;
  }
  
  static void exc_exit (Exc *this) {
    puts(exc_msg(this));
  
    // Arr[char]
    Arr *st = exc_stack(this);
    printf("\nObtained %d stack frames.\n", arr_size(st));
  
    for (int i = 0; i < arr_size(st); ++i) {
      puts(arr_get(st, i));
    }
  
    exit(1);
  }
  
  void exc_init () {
    if (pool) {
      return;
    }
    pool = arr_new();
    pthread_mutex_init(&mutex, NULL);
  
    jmp_buf *bf = MALLOC(jmp_buf);
    Exc *exc = exc_new(pthread_self(), bf);
    arr_push(pool, exc);
  
    int val = setjmp(*bf);
    if (val) {
      Exc *exc = exc_get();
      exc_exit(exc);
    }
  }
  
  void exc_thread_init (void) {
    if (pool) {
      pthread_mutex_lock(&mutex);
  
      pthread_t self = pthread_self();
      jmp_buf *bf = MALLOC(jmp_buf);
      Exc *exc = exc_new(self, bf);
  
      int i = -1;
      EACH(pool, Exc, exc2)
        if (pthread_equal(exc2->thread, self)) {
          i = _i;
          break;
        }
      _EACH
  
      if (i == -1) {
        arr_push(pool, exc);
      } else {
        arr_set(pool, i, exc);
      }
  
      pthread_mutex_unlock(&mutex);
  
      int val = setjmp(*bf);
      if (val) {
        Exc *exc = exc_get();
        exc_exit(exc);
      }
    } else {
      puts("'exc_init()' has not been called");
      exit(1);
    }
  }
  
  void exc_thread_end (void) {
    if (pool) {
      pthread_mutex_lock(&mutex);
  
      pthread_t th = pthread_self();
      int i = -1;
      EACH(pool, Exc, exc)
        if (pthread_equal(exc->thread, th)) {
          i = _i;
          break;
        }
      _EACH
      if (i != -1) {
        arr_remove(pool, i);
      }
  
      pthread_mutex_unlock(&mutex);
    } else {
      puts("'exc_init()' has not been called");
      exit(1);
    }
  }
  
  void exc_add (jmp_buf *jump) {
    Exc *exc = exc_get();
    arr_push(exc->buf, jump);
  }
  
  void exc_remove () {
    Exc *exc = exc_get();
    arr_pop(exc->buf);
  }
  
  Exc *exc_get (void) {
    Exc *r = NULL;
    if (pool) {
      pthread_mutex_lock(&mutex);
  
      pthread_t th = pthread_self();
      EACH(pool, Exc, exc)
        if (pthread_equal(exc->thread, th)) {
          r = exc;
          break;
        }
      _EACH
  
      pthread_mutex_unlock(&mutex);
    } else {
      puts("'exc_init()' has not been called");
      exit(1);
    }
  
    if (!r) {
      puts("exc_get: thread not found");
      exit(1);
    }
    return r;
  }
  
  void exc_throw (char *type, char *message, char *file, char *func, int line) {
    Exc *exc = exc_get();
  
    void *array[25];
    size_t size;
    char **strings;
    size = backtrace(array, 25);
    strings = backtrace_symbols(array, size);
    // Arr[char]
    Arr *stack = arr_new();
    RANGE0(i, size) {
      arr_push(stack, str_new(strings[i]));
    }_RANGE
    free(strings);
  
    exc->stack = stack;
    exc->msg = str_f(
      "%s:%d:[%s]: %s", path_base(file), line, func, message
    );
    exc->type = type;
    longjmp(*((jmp_buf *)arr_pop(exc->buf)), 1);
  }
  
  char *exc_range(int begin, int end, int index) {
    return str_f(
      "Index out of range: %d < %d or %d > %d", index, begin, index, end
    );
  }
  
  char *exc_illegal_argument(char *msg, char *expected, char *actual) {
    return str_f(
      "%s\nExpected: %s\n  Actual: %s",
      msg, expected, actual
    );
  }
  
  //
  // time.c ---------------------------------
  //
  // Copyright 25-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  static time_t to_time (Time this) {
    return (time_t)(this / 1000);
  }
  
  static Time from_time (time_t tm) {
    return (Time)tm * 1000;
  }
  
  static int day_light_correction (int day, int month, int year) {
    struct tm t;
    memset(&t, 0, sizeof(struct tm));
    t.tm_year = year - 1900;
    t.tm_mon = month;
    t.tm_mday = day;
    t.tm_hour = 12;
  
    time_t t2 = mktime(&t);
    int h = localtime(&t2)->tm_hour;
    return 12 - h;
  }
  
  Time time_now (void) {
    struct timeval tm;
    gettimeofday(&tm, NULL);
    return tm.tv_sec * 1000 + tm.tv_usec / 1000;
  }
  
  Time time_new (int day, int month, int year) {
    struct tm t;
    memset(&t, 0, sizeof(struct tm));
    t.tm_year = year - 1900;
    t.tm_mon = month;
    t.tm_mday = day;
    t.tm_hour = 12 + day_light_correction(day, month, year);
    return from_time((time_t) mktime(&t));
  }
  
  Time time_new_time (
    int day, int month, int year, int hour, int minute, int second
  ) {
    struct tm t;
    memset(&t, 0, sizeof(struct tm));
    t.tm_year = year - 1900;
    t.tm_mon = month;
    t.tm_mday = day;
    t.tm_hour = hour + day_light_correction(day, month, year);
    t.tm_min = minute;
    t.tm_sec = second;
  
    return from_time((time_t) mktime(&t));
  }
  
  static Time from_str(char *date) {
    char tpl[5];
    memset (tpl, 0, 5);
    memcpy(tpl, date + 6, 2);
    int d = atoi(tpl);
    memcpy(tpl, date + 4, 2);
    int m = atoi(tpl);
    memcpy(tpl, date, 4);
    int y = atoi(tpl);
    return time_new(d, m - 1, y);
  }
  
  Time time_from_str (char *date) {
    if (strlen(date) != 8 && !math_digits(date))
      EXC_ILLEGAL_ARGUMENT("Bad date", "Date string", date);
    return from_str(date);
  }
  
  static Time from_iso_us (int is_iso, char *date, char sep) {
    // <char>
    Arr *parts = str_csplit(date, sep);
    if (arr_size(parts) == 3) {
      char *d = arr_get(parts, (is_iso) ? 0 : 1);
      char *m = arr_get(parts, (is_iso) ? 1 : 0);
      char *y = arr_get(parts, 2);
  
      if (strlen(d) == 1) d = str_f("%s%s", "0", d);
      if (strlen(m) == 1) m = str_f("%s%s", "0", m);
      if (strlen(y) == 2) y = str_f("%s%s", "20", y);
  
      if (strlen(d) == 2 && strlen(m) == 2 && strlen(y) == 4)
        return from_str(str_f("%s%s%s", y, m, d));
    }
    EXC_ILLEGAL_ARGUMENT(
      "Bad date",
      str_f(
        "%s date string with separator '%c'",
        (is_iso) ? "ISO" : "'EN'", sep
      ),
      date
    );
  
    return 0; // Unreacheable
  }
  
  Time time_from_iso (char *date) {
    return from_iso_us(TRUE, date, '/');
  }
  
  Time time_from_us (char *date) {
    return from_iso_us(FALSE, date, '/');
  }
  
  Time time_from_iso_sep (char *date, char sep) {
    return from_iso_us(TRUE, date, sep);
  }
  
  Time time_from_us_sep (char *date, char sep) {
    return from_iso_us(FALSE, date, sep);
  }
  
  int time_day (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_mday;
  }
  
  int time_month (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_mon;
  }
  
  int time_year (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_year + 1900;
  }
  
  int time_year_day (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_yday;
  }
  
  int time_week_day (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_wday;
  }
  
  int time_hour (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_hour;
  }
  
  int time_minute (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_min;
  }
  
  int time_second (Time this) {
    time_t t = to_time(this);
    return localtime(&t)->tm_sec;
  }
  
  int time_millisecond (Time this) {
    return this % 1000;
  }
  
  Time time_add (Time this, int days) {
    return this + (Time)days * 86400000;
  }
  
  int time_df (Time t1, Time t2) {
    return (t1 / 86400000) - (t2 / 86400000);
  }
  
  int time_eq (Time t1, Time t2) {
    return (time_df(t1, t2)) ? FALSE : TRUE;
  }
  
  char *time_f (Time this, char *template) {
    char *s, *rs;
    time_t tthis = to_time(this);
    struct tm *t = localtime(&tthis);
    int size = 126;
    while (1) {
      rs = (char *)calloc(size, 1); // calloc ok
      if (strftime (rs, size, template, t)) {
        s = str_new(rs);
        free(rs); // free ok
        break;
      }
      free(rs); // free ok
      size += size;
    }
    return s;
  }
  
  char *time_to_str (Time this) {
    return time_f(this, "%Y%m%d");
  }
  
  char *time_to_iso (Time this) {
    return time_f(this, "%d/%m/%Y");
  }
  
  char *time_to_us (Time this) {
    return time_f(this, "%m-%d-%Y");
  }
  
  //
  // file.c ---------------------------------
  //
  // Copyright 25-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct file_File {
    struct flock *lock;
    FILE *f;
  };
  
  static File *lckFile_new(struct flock *lock, FILE *f) {
    File *this = MALLOC(File);
    this->lock = lock;
    this->f = f;
    return this;
  }
  
  char *file_tmp (char *dir, char *path) {
    if (!*dir) dir = "/tmp";
    char *fpath = NULL;
    for (;;) {
      char *k = cryp_genk(16);
      char *pid = str_f("%d", (int)getpid());
      char *v = str_left(cryp_encode(k, pid), 8);
      fpath = str_f("%s/%s%s", dir, path, str_replace(v, "/", "-"));
      if (!file_exists(fpath)) break;
    }
    return fpath;
  }
  
  char *file_wd (void) {
    char *d = getcwd(NULL, 0);
    if (!d)
      EXC_IO(str_f("Working directory can no be find: %s", strerror(errno)));
  
    char *r = str_new(d);
    free(d);  // free is ok
    return r;
  }
  
  void file_cd (char *path) {
    if (chdir(path)) {
      EXC_IO(str_f(
        "Fail changing the working directory to %s: %s",
        path, strerror(errno)
      ));
    }
  }
  
  void file_mkdir (char *path) {
    if (!*path || (*path == '/' && !path[1])) {
      return;
    }
  
    char *p;
    if (*path != '/') {
      char *cwd = file_wd();
      p = str_f("%s/%s", cwd, path);
    } else {
      p = path;
    }
    p = path_parent(p);
    file_mkdir(p);
  
    if (mkdir(path, 0755) && errno != EEXIST)
      EXC_IO(str_f("Fail making directory %s: %s" , path, strerror(errno)));
  }
  
  // Arr<char>
  Arr *file_dir (char *path) {
    DIR *d = opendir(path);
    if (!d)
      EXC_IO(str_f("Fail reading directory %s: %s", path, strerror(errno)));
  
    // Arr<char>
    Arr *a = arr_new();
    struct dirent *res;
    while ((res = readdir(d))) {
      char *name = res->d_name;
      if (str_eq(name, ".") || str_eq(name, "..")) {
        continue;
      }
      arr_push(a, str_new(name));
    }
    closedir(d);
    return a;
  }
  
  void file_del (char *path) {
    struct stat buf;
    if (stat(path, &buf) && errno != ENOENT)
        EXC_IO(str_f("Fail deleting %s: %s", path, strerror(errno)));
  
    if (S_ISDIR(buf.st_mode)) {
      // <char>
      Arr *names = file_dir(path);
      EACH(names, char, name) {
        file_del(str_f("%s/%s", path, name));
      }_EACH
  
      if (rmdir(path) && errno != ENOENT)
        EXC_IO(str_f("Fail deleting %s: %s", path, strerror(errno)));
    } else {
      if (unlink(path) && errno != ENOENT)
        EXC_IO(str_f("Fail deleting %s: %s", path, strerror(errno)));
    }
  }
  
  void file_rename (char *old_path, char *new_path) {
    if (rename(old_path, new_path) == -1)
      EXC_IO(str_f(
        "Fail renaming '%s' to '%s: %s", old_path, new_path, strerror(errno)
      ));
  }
  
  void file_link (char *path, char *link) {
    if (symlink(path, link) == -1)
      EXC_IO(str_f(
        "Fail linking '%s' to '%s: %s", link, path, strerror(errno)
      ));
  }
  
  int file_exists (char *path) {
    struct stat buf;
    if (stat(path, &buf)) {
      if (errno == ENOENT) {
        return FALSE;
      }
      EXC_IO(str_f("Fail reading %s: %s", path, strerror(errno)));
    }
    return TRUE;
  }
  
  int file_is_directory (char *path) {
    struct stat buf;
    if (stat(path, &buf)) {
      if (errno == ENOENT) {
        return FALSE;
      }
      EXC_IO(str_f("Fail reading %s: %s", path, strerror(errno)));
    }
    if (S_ISDIR(buf.st_mode))
      return TRUE;
    return FALSE;
  }
  
  int file_is_link (char *path) {
    struct stat buf;
    if (lstat(path, &buf)) {
      if (errno == ENOENT) {
        return FALSE;
      }
      EXC_IO(str_f("Fail reading %s: %s", path, strerror(errno)));
    }
    if (S_ISLNK(buf.st_mode))
      return TRUE;
    return FALSE;
  }
  
  int file_is_regular (char *path) {
    struct stat buf;
    if (stat(path, &buf)) {
      if (errno == ENOENT) {
        return FALSE;
      }
      EXC_IO(str_f("Fail reading %s: %s", path, strerror(errno)));
    }
    if (S_ISREG(buf.st_mode))
      return TRUE;
    return FALSE;
  }
  
  struct stat *file_info (char *path) {
    struct stat *r = MALLOC(struct stat);
    if (stat(path, r))
      EXC_IO(str_f("Fail reading %s: %s", path, strerror(errno)));
  
    return r;
  }
  
  int file_size(char *path) {
    struct stat *i = file_info (path);
    return i->st_size;
  }
  
  Time file_modified(char *path) {
    struct stat *i = file_info (path);
    return ((Time)i->st_mtime) * 1000;
  }
  
  char *file_read (char *path) {
    FILE *fl;
    size_t len = 0;
    struct flock lck = {
      .l_whence = SEEK_SET,
      .l_start = 0,
      .l_len = 0,
    };
  
    fl = fopen(path, "r");
    if (!fl)
      EXC_IO(str_f("Fail openning %s: %s", path, strerror(errno)));
  
    lck.l_type = F_RDLCK;
    fcntl (fileno(fl), F_SETLKW, &lck);
  
    Buf *bf = buf_new();
    char *line = NULL;
    while (getline(&line, &len, fl) != -1) {
      buf_add(bf, line);
      free(line); // free ok
      line = NULL;
    }
    free(line); // free ok
  
    lck.l_type = F_UNLCK;
    fcntl (fileno(fl), F_SETLK, &lck);
    fclose(fl);
  
    return str_new(buf_str(bf));
  }
  
  void file_write (char *path, char *text) {
    FILE *fl;
    int error;
    struct flock lck = {
      .l_whence = SEEK_SET,
      .l_start = 0,
      .l_len = 0,
    };
  
    fl = fopen(path, "w");
    if (!fl)
      EXC_IO(str_f("Fail openning %s: %s", path, strerror(errno)));
  
    lck.l_type = F_WRLCK;
    fcntl (fileno(fl), F_SETLKW, &lck);
  
    error = fputs(text, fl);
  
    lck.l_type = F_UNLCK;
    fcntl (fileno(fl), F_SETLK, &lck);
  
    if (error == EOF || error < 0) {
      fclose(fl);
      EXC_IO(str_f("Fail writing '%s': %s", path, strerror(error)));
    }
    fclose(fl);
  }
  
  void file_append (char *path, char *text) {
    FILE *fl;
    int error;
    struct flock lck = {
      .l_whence = SEEK_SET,
      .l_start = 0,
      .l_len = 0,
    };
  
    fl = fopen(path, "a");
    if (!fl)
      EXC_IO(str_f("Fail openning %s: %s", path, strerror(errno)));
  
    lck.l_type = F_WRLCK;
    fcntl (fileno(fl), F_SETLKW, &lck);
  
    error = fputs(text, fl);
  
    lck.l_type = F_UNLCK;
    fcntl (fileno(fl), F_SETLK, &lck);
  
    if (error == EOF || error < 0) {
      fclose(fl);
      EXC_IO(str_f("Fail writing '%s': %s", path, strerror(error)));
    }
    fclose(fl);
  }
  
  void file_copy (char *source_path, char *target_path) {
    if (!strcmp(source_path, target_path)) {
      return;
    }
  
    FILE *f1;
    FILE *f2;
  
    char  buffer[32678];
    size_t  n;
  
    if ((f1 = fopen(source_path, "rb")) == 0)
      EXC_IO(str_f("Fail openning '%s': %s", source_path, strerror(errno)));
  
    if ((f2 = fopen(target_path, "wb")) == 0)
      EXC_IO(str_f("Fail openning '%s': %s", target_path, strerror(errno)));
  
    while ((n = fread(buffer, sizeof(char), sizeof(buffer), f1)) > 0) {
      if (fwrite(buffer, sizeof(char), n, f2) != n)
        EXC_IO(str_f("Fail writing '%s': %s", target_path, strerror(errno)));
    }
  
    fclose(f1);
    fclose(f2);
  }
  
  static File *lck_new(FILE *file) {
    struct flock *lck = MALLOC(struct flock);
    lck->l_whence = SEEK_SET;
    lck->l_start = 0;
    lck->l_len = 0;
    return lckFile_new(lck, file);
  }
  
  File *file_ropen (char *path) {
    FILE *file = fopen(path, "r");
    if (!file)
      EXC_IO(str_f("Fail opening '%s': %s", path, strerror(errno)));
  
    File *r = lck_new(file);
    r->lock->l_type = F_RDLCK;
    fcntl (fileno(file), F_SETLKW, r->lock);
    return r;
  }
  
  File *file_wopen (char *path) {
    FILE *file = fopen(path, "w");
    if (!file)
      EXC_IO(str_f("Fail opening '%s': %s", path, strerror(errno)));
  
    File *r = lck_new(file);
    r->lock->l_type = F_WRLCK;
    fcntl (fileno(file), F_SETLKW, r->lock);
    return r;
  }
  
  File *file_aopen (char *path) {
    FILE *file = fopen(path, "a");
    if (!file)
      EXC_IO(str_f("Fail opening '%s': %s", path, strerror(errno)));
  
    File *r = lck_new(file);
    r->lock->l_type = F_WRLCK;
    fcntl (fileno(file), F_SETLKW, r->lock);
    return r;
  }
  
  char *file_read_line (File *lck) {
    size_t len = 0;
    errno = 0;
    char *line= NULL;
    if (getline(&line, &len, lck->f) != -1) {
      char *r = str_new(line);
      free(line); // free ok
      return r;
    }
    free(line); // free ok
    if (errno) {
      file_close(lck);
      EXC_IO(str_f("Fail file_read_line: %s", strerror(errno)));
    }
    return "";
  }
  
  void file_write_text (File *lck, char *text) {
    int error = fputs(text, lck->f);
    if (error == EOF || error < 0) {
      file_close(lck);
      EXC_IO(str_f("Fail file_write_line: %s", strerror(errno)));
    }
  }
  
  Bytes *file_read_bin_buf (File *lck, int buffer) {
    unsigned char bs[buffer];
    int len = (int)fread(bs, 1, buffer, lck->f);
    if (len == -1) {
      file_close(lck);
      EXC_IO(str_f("Fail file_read_bin_buf: %s", strerror(errno)));
    }
    if (len == 0) {
      return bytes_new();
    }
    return bytes_from_bytes(bs, len);
  }
  
  Bytes *file_read_bin (File *lck) {
    return file_read_bin_buf(lck, 8192);
  }
  
  void file_write_bin (File *lck, Bytes *bs) {
    if (fwrite(bytes_bs(bs), bytes_len(bs), 1, lck->f) == -1)
      EXC_IO(str_f("Fail file_write_bin: %s", strerror(errno)));
  }
  
  void file_close (File *lck) {
    FILE *fl = lck->f;
    struct flock *lock = lck->lock;
  
    lock->l_type = F_UNLCK;
    fcntl (fileno(fl), F_SETLK, &lock);
    fclose(fl);
  }
  
  
  //
  // tp.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct tp_Tp {
    void *e1;
    void *e2;
  };
  
  Tp *tp_new (void *e1, void *e2) {
    Tp *this = MALLOC(Tp);
    this->e1 = e1;
    this->e2 = e2;
    return this;
  }
  
  void *tp_e1 (Tp *this) {
    return this->e1;
  }
  
  void *tp_e2 (Tp *this) {
    return this->e2;
  }
  
  //
  // tp3.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct tp3_Tp3 {
    void *e1;
    void *e2;
    void *e3;
  };
  
  Tp3 *tp3_new (void *e1, void *e2, void *e3) {
    Tp3 *this = MALLOC(Tp3);
    this->e1 = e1;
    this->e2 = e2;
    this->e3 = e3;
    return this;
  }
  
  void *tp3_e1 (Tp3 *this) {
    return this->e1;
  }
  
  void *tp3_e2 (Tp3 *this) {
    return this->e2;
  }
  
  void *tp3_e3 (Tp3 *this) {
    return this->e3;
  }
  
  //
  // it.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct it_It {
    void *o;
    Opt *e;
    Opt *(*next)(void *o);
  };
  
  typedef Opt *(*it_Next)(void *);
  
  It *it_new(
    void *o,
    Opt *(*next)(void *o)
  ) {
    It *this = MALLOC(It);
    this->o = o;
    this->next = next;
    this->e = next(o);
    return this;
  }
  
  static Opt *empty_next (void *o) { return opt_none(); }
  It *it_empty (void) {
    return it_new(opt_none(), empty_next);
  }
  
    //--
    typedef struct {
      void *e;
      int is_first;
    } it_unary_O;
    static Opt *unary_next(it_unary_O *o) {
      if (o->is_first) {
        o->is_first = 0;
        return opt_some(o->e);
      }
      return opt_none();
    }
  It *it_unary (void *e) {
    it_unary_O *o = MALLOC(it_unary_O);
    o->e = e;
    o->is_first = 1;
    return it_new(o, (it_Next)unary_next);
  }
  
    //--
    typedef struct {
      int i;
      int end;
    } it_range_O;
    static Opt *range_next (it_range_O *o) {
      int i = (o->i)++;
      if (i >= o->end) {
        return opt_none();
      }
      int *r = ATOMIC(sizeof(int));
      *r = i;
      return opt_some(r);
    }
  It *it_range (int begin, int end) {
    it_range_O *o = MALLOC(it_range_O);
    o->i = begin;
    o->end = end;
    return it_new(o, (it_Next)range_next);
  }
  
  It *it_range0 (int end) {
    return it_range(0, end);
  }
  
  int it_has_next (It *this) {
    return opt_get(this->e) ? TRUE : FALSE;
  }
  
  static Opt *it_onext (It *this) {
    Opt *r = this->e;
    this->e = this->next(this->o);
    return r;
  }
  
  void *it_next (It *this) {
    return opt_get(it_onext(this));
  }
  
  void *it_peek (It *this) {
    return opt_get(this->e);
  }
  
  It *it_add(It *this, void *element) {
    return it_cat(this, it_unary(element));
  }
  
  It *it_add0(It *this, void *element) {
    return it_cat(it_unary(element), this);
  }
  
    //--
    typedef struct {
      It *it1;
      It *it2;
    } it_cat_O;
    static Opt *cat_next (it_cat_O *o) {
      return (it_has_next(o->it1)) ? it_onext(o->it1)
        : (it_has_next(o->it2)) ? it_onext(o->it2) : opt_none();
    }
  It *it_cat (It *this, It *another) {
    it_cat_O *o = MALLOC(it_cat_O);
    o->it1 = this;
    o->it2 = another;
    return it_new(o, (it_Next)cat_next);
  }
  
    //--
    typedef struct {
      It *it;
      int i;
      int n;
    } it_take_O;
    static Opt *take_next (it_take_O *o) {
      if (o->i < o->n && it_has_next(o->it)) {
        o->i += 1;
        return it_onext(o->it);
      }
      else return opt_none();
    }
  It *it_take (It *this, int n) {
    it_take_O *o = MALLOC(it_take_O);
    o->it = this;
    o->n = n;
    o->i = 0;
    return it_new(o, (it_Next)take_next);
  }
  
    //--
    typedef struct {
      It *it;
      int (*f)(void *e);
    } it_takef_O;
    static Opt *takef_next (it_takef_O *o) {
      return it_has_next(o->it) && o->f(it_peek(o->it))
        ? it_onext(o->it) : opt_none();
    }
  It *it_takef (It *this, int (*predicate)(void *e)) {
    it_takef_O *o = MALLOC(it_takef_O);
    o->it = this;
    o->f = predicate;
    return it_new(o, (it_Next)takef_next);
  }
  
  It *it_drop (It *this, int n) {
    int i = 0;
    while (it_has_next(this) && i++ < n)
      it_next(this);
    return this;
  }
  
  It *it_dropf (It *this, int (*predicate)(void *e)) {
    while (it_has_next(this) && predicate(it_peek(this)))
      it_next(this);
    return this;
  }
  
    //--
    typedef struct {
      It *it;
      int (*f)(void *e);
    } it_filter_O;
    static Opt *filter_next (it_filter_O *o) {
      for(;;) {
        if (!it_has_next(o->it)) return opt_none();
        Opt *onext = it_onext(o->it);
        void *next = opt_get(onext);
        if (o->f(next)) return onext;
      }
    }
  It *it_filter (It *this, int (*predicate)(void *e)) {
    it_filter_O *o = MALLOC(it_filter_O);
    o->it = this;
    o->f = predicate;
    return it_new(o, (it_Next)filter_next);
  }
  
    //--
    typedef struct {
      It *it;
      void *(*f)(void *);
    } it_map_O;
    static Opt *map_next (it_map_O *o) {
      return it_has_next(o->it) ? opt_some(o->f(it_next(o->it))) : opt_none();
    }
  It *it_map (It *this, void *(*converter)(void *e)) {
    it_map_O *o = MALLOC(it_map_O);
    o->it = this;
    o->f = converter;
    return it_new(o, (it_Next)map_next);
  }
  
    //--
    typedef struct {
      It *it;
      int is_first;
      void *(*f1)(void *);
      void *(*f)(void *);
    } it_map2_O;
    static Opt *map2_next(it_map2_O *o) {
      if (!it_has_next(o->it)) return opt_none();
      if (o->is_first) {
        o->is_first = 0;
        return opt_some(o->f1(it_next(o->it)));
      }
      return opt_some(o->f(it_next(o->it)));
    }
  It *it_map2 (It *this, void *(*conv1)(void *e), void *(*conv2)(void *e)) {
    it_map2_O *o = MALLOC(it_map2_O);
    o->it = this;
    o->is_first = 1;
    o->f1 = conv1;
    o->f = conv2;
    return it_new(o, (it_Next)map2_next);
  }
  
    //--
    typedef struct {
      It *it1;
      It *it2;
    } it_zip_O;
    static Opt *zip_next(it_zip_O *o) {
      return it_has_next(o->it1) && it_has_next(o->it2)
        ? opt_some(tp_new(it_next(o->it1), it_next(o->it2)))
        : opt_none();
    }
  It *it_zip (It *it1, It *it2) {
    it_zip_O *o = MALLOC(it_zip_O);
    o->it1 = it1;
    o->it2 = it2;
    return it_new(o, (it_Next)zip_next);
  }
  
    //--
    typedef struct {
      It *it1;
      It *it2;
      It *it3;
    } it_zip3_O;
    static Opt *zip3_next(it_zip3_O *o) {
      return it_has_next(o->it1) && it_has_next(o->it2) && it_has_next(o->it3)
        ? opt_some(tp3_new(
            it_next(o->it1),
            it_next(o->it2),
            it_next(o->it3)
          ))
        : opt_none();
    }
  It *it_zip3 (It *it1, It *it2, It *it3) {
    it_zip3_O *o = MALLOC(it_zip3_O);
    o->it1 = it1;
    o->it2 = it2;
    o->it3 = it3;
  
    return it_new(o, (it_Next)zip3_next);
  }
  
  It *it_reverse (It *this) {
    Arr *a = arr_from_it(this);
    arr_reverse(a);
    return arr_to_it(a);
  }
  
  It *it_sort (It *this, int (*comparator)(void *, void *)) {
    Arr *a = arr_from_it(this);
    arr_sort(a, comparator);
    return arr_to_it(a);
  }
  
  void it_each (It *this, void (*f)(void *e)) {
    while (it_has_next(this)) f(it_next(this));
  }
  
  void it_each_ix (It *this, void (*f)(void *e, int ix)) {
    int c = 0;
    while (it_has_next(this))
      f(it_next(this), c++);
  }
  
  int it_count (It *this) {
    int c = 0;
    while (it_has_next(this)) {
      it_next(this);
      ++c;
    }
    return c;
  }
  
  int it_eq (It *it1, It *it2, int (*feq)(void *e1, void *e2)) {
    while (it_has_next(it1) && it_has_next(it2)) {
      void *e1 = it_next(it1);
      void *e2 = it_next(it2);
      if (!feq(e1, e2))
        return 0;
    }
    if (it_has_next(it1) || it_has_next(it2))
      return 0;
    return 1;
  }
  
  int it_index (It *this, int (*predicate)(void *e)) {
    int ix = 0;
    while(it_has_next(this)) {
      if (predicate(it_next(this)))
        return ix;
      ++ix;
    }
    return -1;
  }
  
  int it_contains (It *this, int (*predicate)(void *e)) {
    while(it_has_next(this))
      if (predicate(it_next(this)))
        return 1;
    return 0;
  }
  
  int it_last_index (It *this, int (*predicate)(void *e)) {
    int r = -1;
    int ix = 0;
    while(it_has_next(this)) {
      if (predicate(it_next(this)))
        r = ix;
      ++ix;
    }
    return r;
  }
  
  Opt *it_find (It *this, int (*predicate)(void *e)) {
    while(it_has_next(this)) {
      void *next = it_next(this);
      if (predicate(next)) {
        return opt_some(next);
      }
    }
    return opt_none();
  }
  
  Arr *it_to (It *this) {
    return arr_from_it (this);
  }
  
  It *it_from (Arr *a) {
    return arr_to_it(a);
  }
  
  // Tp[Arr, Arr]
  Tp *it_duplicates (It *this, int (feq)(void *e1, void *e2)) {
    Arr *d = arr_new();
    Arr *r = arr_new();
    void fn (void *e1) {
      int fcontains (void *e2) { return feq(e1, e2); }
      if (it_contains(it_from(r), fcontains)) {
        if (!it_contains(it_from(d), fcontains)) {
          arr_push(d, e1);
        }
      } else {
        arr_push(r, e1);
      }
    }
    it_each(this, fn);
  
    return tp_new(d, r);
  }
  
  //
  // kv.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct kv_Kv {
    char *key;
    void *value;
  };
  
  Kv *kv_new (char *key, void *value) {
    Kv *this = MALLOC(Kv);
    this->key = key;
    this->value = value;
    return this;
  }
  
  char *kv_key (Kv *this) {
    return this->key;
  }
  
  void *kv_value (Kv *this) {
    return this->value;
  }
  
  char *kv_to_js (Kv *this, char *(*to)(void *e)) {
    return js_wa(arr_new_from(
      js_ws(this->key),
      to(this->value),
      NULL
    ));
  }
  
  Kv *kv_from_js (char *js, void *(*from)(char *ejs)) {
    // <char>
    Arr *a = js_ra(js);
    return kv_new(
      js_rs(arr_get(a, 0)),
      from(arr_get(a, 1))
    );
  }
  
  //
  // map.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  Map *map_new(void) {
    return (Map *)arr_new();
  }
  
  int map_size(Map *this) {
    return arr_size((Arr *)this);
  }
  
  void map_add(Map *this, char *key, void *value) {
    if (map_has_key(this, key))
      EXC_ILLEGAL_ARGUMENT(
        str_f("Fail adding the key '%s'", key),
        "A new key",
        "Key is duplicate"
      );
    arr_push((Arr *)this, kv_new(key, value));
  }
  
  void map_set(Map *this, char *key, void *value) {
    EACH((Arr *)this, Kv, kv) {
      if (!strcmp(kv_key(kv), key)) {
        arr_set((Arr *)this, _i, kv_new(key, value));
        return;
      }
    }_EACH
    EXC_ILLEGAL_ARGUMENT(
      str_f("Fail changing the value of key '%s'", key),
      "Key already existing",
      "Key does not exist"
    );
  }
  
  void map_put(Map *this, char *key, void *value) {
    int todo = TRUE;
    EACH((Arr *)this, Kv, kv) {
      if (!strcmp(kv_key(kv), key)) {
        arr_set((Arr *)this, _i, kv_new(key, value));
        todo = FALSE;
        break;
      }
    }_EACH
  
    if (todo) arr_push((Arr *)this, kv_new(key, value));
  }
  
  int map_has_key(Map *this, char *key) {
    EACH((Arr *)this, Kv, kv) {
      if (!strcmp(kv_key(kv), key)) return TRUE;
    }_EACH
    return FALSE;
  }
  
  Opt *map_get(Map *this, char *key) {
    EACH((Arr *)this, Kv, kv) {
      if (!strcmp(kv_key(kv), key)) return opt_some(kv_value(kv));
    }_EACH
    return opt_none();
  }
  
  void map_remove(Map *this, char *key) {
    int ix = -1;
    EACH((Arr *)this, Kv, kv) {
      if (!strcmp(kv_key(kv), key)) {
        ix = _i;
        break;
      }
    }_EACH
  
    if (ix != -1) arr_remove((Arr *)this, ix);
  }
  
  // <char>
  Arr *map_keys(Map *this) {
    //(
      char *fmap (Kv *kv) {
        return kv_key(kv);
      }
    //)
    return arr_map((Arr *)this, (FMAP)fmap);
  }
  
  //<kv>
  Arr *map_to_array(Map *this) {
    return arr_copy((Arr *)this);
  }
  
  // Arr<kv>
  Map *map_from_array(Arr *this) {
    // <Kv>
    Arr *r = arr_copy(this);
    //(
      int feq (Kv *e1, Kv *e2) {
        return !str_cmp(kv_key(e1), kv_key(e2));
      }
    //)
    arr_duplicates(r, (FEQ)feq);
    return (Map *)r;
  }
  
  void map_sort(Map *this) {
    //(
      int greater(Kv *e1, Kv *e2) {
        return str_greater(kv_key(e1), kv_key(e2));
      }
    //)
    arr_sort((Arr *)this, (FEQ)greater);
  }
  
  void map_sort_locale(Map *this) {
    //(
      int greater(Kv *e1, Kv *e2) {
        return str_greater_locale(kv_key(e1), kv_key(e2));
      }
    //)
    arr_sort((Arr *)this, (FEQ)greater);
  }
  
  char *map_to_js(Map *this, char *(*to)(void *e)) {
      //-- <char>
      Kv *fto (Kv *kv) { return kv_new(kv_key(kv), to(kv_value(kv))); }
    return js_wo((Map *)arr_map((Arr *)this, (FMAP)fto));
  }
  
  // <char>
  Map *map_from_js(char *js, void *(*from)(char *jse)) {
      //-- kv is Kv<char>
      Kv *ffrom (Kv *kv) { return kv_new(kv_key(kv), from(kv_value(kv))); }
    return (Map *)arr_map((Arr *)js_ro(js), (FMAP)ffrom);
  }
  
  //
  // js.c ---------------------------------
  //
  // Copyright 24-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  static void json_unicode(Buf *bf, char *hexdigits) {
    char hexvalue (char ch) {
      return (ch <= '9') ? ch - '0' : toupper(ch) - 'A' + 10;
    }
    unsigned int codepoint =
      hexvalue(*hexdigits) * 4096 +
      hexvalue(*(hexdigits + 1)) * 256 +
      hexvalue(*(hexdigits + 2)) * 16 +
      hexvalue(*(hexdigits + 3));
    if (codepoint < 0x80) {
      buf_cadd(bf, (codepoint>>0  & 0x7F) | 0x00);
      return;
    }
    if (codepoint < 0x0800) {
      buf_cadd(bf, (codepoint>>6  & 0x1F) | 0xC0);
      buf_cadd(bf, (codepoint>>0  & 0x3F) | 0x80);
      return;
    }
    buf_cadd(bf, (codepoint>>12 & 0x0F) | 0xE0);
    buf_cadd(bf, (codepoint>>6  & 0x3F) | 0x80);
    buf_cadd(bf, (codepoint>>0  & 0x3F) | 0x80);
  }
  
  static char *json_blanks(char *json) {
    while (*json && ((unsigned char)*json) <= ' ') {
      ++json;
    }
    return json;
  }
  
  inline
  static char *json_snull(char *json) {
    return json_blanks(json + 4);
  }
  
  static char *json_sbool(char *json) {
    if (*json == 't') {
      return json_blanks(json + 4);
    }
    return json_blanks(json + 5);
  }
  
  static char *json_snumber(char *j) {
    while (
      *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char) *j) > ' '
    ) {
      ++j;
    }
    return json_blanks(j);
  }
  
  static char *json_sstring(char *j) {
    ++j;
    while (*j && *j != '"') {
      if (*j++ == '\\') {
        if (*j) {
          ++j;
        }
      }
    }
    if (*j) {
      ++j;
    }
    return json_blanks(j);
  }
  
  static char *json_selement(char *j);
  
  static char *json_sarray(char *j) {
    ++j;
    j = json_blanks(j);
    while (*j && *j != ']') {
      j = json_selement(j);
      if (*j == ',') {
        ++j;
        j = json_blanks(j);
      }
    }
    if (*j) {
      ++j;
    }
    return json_blanks(j);
  }
  
  static char *json_sobject(char *j) {
    ++j;
    j = json_blanks(j);
    while (*j && *j != '}') {
      j = json_sstring(j);
      ++j;
      j = json_selement(j);
      if (*j == ',') {
        ++j;
        j = json_blanks(j);
      }
    }
    if (*j) {
      ++j;
    }
    return json_blanks(j);
  }
  
  static char *json_selement(char *j) {
    j = json_blanks(j);
    switch (*j) {
    case 'n': return json_snull(j);
    case 't':
    case 'f': return json_sbool(j);
    case '"': return json_sstring(j);
    case '[': return json_sarray(j);
    case '{': return json_sobject(j);
    case '-': return json_snumber(j);
    default :
      if (*j >= '0' && *j <= '9') {
        return json_snumber(j);
      } else {
        if (*j) {
          ++j;
        }
        return j;
      }
    }
  }
  
  static int json_rend(char *json) {
    while (*json && ((unsigned char)*json) <= ' ') {
      ++json;
    }
    return *json ? 0 : 1;
  }
  
  static char *errorf(char *json) {
    return str_runes_len(json) > 70
      ? str_f("%s...", arr_join(arr_take(str_runes(json), 67), ""))
      : json
    ;
  }
  
  int js_is_null (char *json) {
    char *j = json_blanks(json);
    if (memcmp(j, "null", 4)) {
      return 0;
    }
    return json_rend(j + 4);
  }
  
  int js_rb (char *json) {
    char *jsons = json_blanks(json);
    int r;
  
    char *j = jsons;
    if (memcmp(j, "true", 4)) {
      if (memcmp(j, "false", 5))
        EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Boolean value", errorf(json));
  
      r = 0;
      j += 5;
    } else {
      r = 1;
      j += 4;
    }
    if (!json_rend(j))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Boolean value (spare characters)", errorf(json));
  
    return r;
  }
  
  int js_ri (char *json) {
    return js_rl(json);
  }
  
  long js_rl (char *json) {
    char *jsons = json_blanks(json);
    char *j = jsons;
    if (*j != '-' && (*j < '0' || *j > '9'))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Long value", errorf(json));
  
    Buf *bf = buf_new();
    while (
      *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char)*j) > ' '
    ) {
      ++j;
    }
    buf_add_buf(bf, jsons, j - jsons);
    char *n = buf_str(bf);
    if (!json_rend(j))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Long value (spare characters)", errorf(json));
  
    char *tail;
    errno = 0;
    long r = strtol(n, &tail, 10);
    if (errno)
      EXC_GENERIC(str_f("Bad JSON string: Long overflow in %s", errorf(json)));
  
    if (*tail)
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Long value", errorf(json));
  
    return r;
  }
  
  double js_rd (char *json) {
    struct lconv *lc = localeconv();
    char *jsons = json_blanks(json);
    char *j = jsons;
    if (*j != '-' && (*j < '0' || *j > '9'))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Float value", errorf(json));
  
    Buf *bf = buf_new();
    while (
      *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char)*j) > ' '
    ) {
      ++j;
    }
    buf_add_buf(bf, jsons, j - jsons);
    char *n = buf_str(bf);
    int ix = str_cindex(n, '.');
    if (ix != -1) {
      n[ix] = *lc->decimal_point;
    }
    if (!json_rend(j))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Float value (spare characters)", errorf(json));
  
    errno = 0;
    char *tail;
    double r = strtod(n, &tail);
    if (errno)
      EXC_GENERIC(str_f("Bad JSON string: Float overflow in %s", errorf(json)));
  
    if (*tail)
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Float value", errorf(json));
  
    return r;
  }
  
  char *js_rs (char *j) {
    int is_hex (char ch) {
      return (ch >= '0' && ch <= '9') ||
        (ch >= 'a' && ch <= 'f') ||
        (ch >= 'A' && ch <= 'F');
    }
  
    char *json = json_blanks(j);
    if (*json != '"')
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "String value (not begin with '\"')", errorf(j));
  
    ++json;
    Buf *bf = buf_new();
    while (*json && *json != '"') {
      if (*json == '\\') {
        ++json;
        switch (*json) {
          case '"' :
          case '\\' :
          case '/' :
            buf_cadd(bf, *json);
            break;
          case 'b' :
            buf_cadd(bf, '\b');
            break;
          case 'f' :
            buf_cadd(bf, '\f');
            break;
          case 'n' :
            buf_cadd(bf, '\n');
            break;
          case 'r' :
            buf_cadd(bf, '\r');
            break;
          case 't' :
            buf_cadd(bf, '\t');
            break;
          case 'u' : {
            ++json;
            int c = 5;
            while (--c) {
              if (!is_hex(*json++))
                EXC_ILLEGAL_ARGUMENT("Bad JSON string", "String value (Bad unicode)", errorf(j));
  
            }
            json_unicode(bf, json - 4);
            continue;
          }
          default :
            EXC_ILLEGAL_ARGUMENT("Bad JSON string", "String value (Bad escape sequence)", errorf(j));
        }
        ++json;
      } else {
        buf_cadd(bf, *json++);
      }
    }
    if (!*json)
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "String value (not end with '\"')", errorf(j));
  
    if (!json_rend(json + 1))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "String value (spare characters)", errorf(j));
  
    return str_new(buf_str(bf));
  }
  
  // <char>
  Arr *js_ra (char *j) {
    char *json = json_blanks(j);
    if (*json != '[')
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Array value (not begin with '[')", errorf(j));
  
    ++json;
    // <char>
    Arr *a = arr_new();
    while (*json && *json != ']') {
      char *tmp = json;
      json = json_selement(json);
      Buf *bf = buf_new();
      buf_add_buf(bf, tmp, json - tmp);
      arr_push(a, str_new(buf_str(bf)));
      if (*json == ',') {
        ++json;
      } else if (*json && *json != ']')
        EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Array value (comma missing)", errorf(j));
  
    }
    if (!*json)
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Array value (not end with ']')", errorf(j));
  
    if (!json_rend(json + 1))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Array value (spare characters)", errorf(j));
  
    return a;
  }
  
  // <char>
  Map *js_ro (char *j) {
    char *json = json_blanks(j);
    if (*json != '{')
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Object value (not begin with '{')", errorf(j));
  
    json = json_blanks(json + 1);
  
    Map *m = map_new();
    while (*json && *json != '}') {
      if (*json != '"')
        EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Object value (bad key)", errorf(j));
  
      char *tmp = json;
      json = json_sstring(json);
      Buf *kbf = buf_new();
      buf_add_buf(kbf, tmp, json - tmp);
  
      if (*json != ':')
        EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Object value (':' is missing)", errorf(j));
  
      ++json;
      tmp = json;
      json = json_selement(json);
      Buf *vbf = buf_new();
      buf_add_buf(vbf, tmp, json - tmp);
  
      map_put(m, js_rs(buf_str(kbf)), str_new(buf_str(vbf)));
  
      if (*json == ',') {
        json = json_blanks(json + 1);
      } else if (*json && *json != '}')
        EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Object value (comma missing)", errorf(j));
  
    }
    if (!*json)
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Object value (not end with '}')", errorf(j));
  
    if (!json_rend(json + 1))
      EXC_ILLEGAL_ARGUMENT("Bad JSON string", "Object value (spare characters)", errorf(j));
  
    return m;
  }
  
  char *js_wn() {
    return str_new("null");
  }
  
  char *js_wb(int value) {
    return str_new(value ? "true" : "false");
  }
  
  char *js_wi(int n) {
    return str_f("%d", n);
  }
  
  char *js_wl(long n) {
    return str_f("%ld", n);
  }
  
  char *js_wf(double n, int scale) {
    return math_ftos(n, scale);
  }
  
  char *js_ws(char *s) {
    Buf *bf = buf_new();
  
    char tmp;
    buf_cadd(bf, '"');
    while (*s) {
      tmp = *s++;
      switch (tmp) {
      case '"':
        buf_add(bf, "\\\"");
        break;
      case '\\':
        buf_add(bf, "\\\\");
        break;
      case '\b':
        buf_add(bf, "\\b");
        break;
      case '\f':
        buf_add(bf, "\\f");
        break;
      case '\n':
        buf_add(bf, "\\n");
        break;
      case '\r':
        buf_add(bf, "\\r");
        break;
      case '\t':
        buf_add(bf, "\\t");
        break;
      default:
        buf_cadd(bf, tmp);
      }
    }
    buf_cadd(bf, '"');
    return str_new(buf_str(bf));
  }
  
  // Arr<char>
  char *js_wa(Arr *a) {
    int size = arr_size(a);
    Buf *bf = buf_new();
    buf_cadd(bf, '[');
    if (size > 0) {
      buf_add(bf, arr_get(a, 0));
      int i;
      for (i = 1; i < size; ++i) {
        buf_cadd(bf, ',');
        buf_add(bf, arr_get(a, i));
      }
    }
    buf_cadd(bf, ']');
    return str_new(buf_str(bf));
  }
  
  // Map<char>
  char *js_wo(Map *m) {
    Buf *bf = buf_new();
    buf_cadd(bf, '{');
    // <char>
    Arr *kvs = map_to_array(m);
    for (int i = 0; i < arr_size(kvs); i++) {
      //<char>
      Kv *kv = arr_get(kvs, i);
      if (i) {
        buf_cadd(bf, ',');
      }
      buf_add(bf, js_ws(kv_key(kv)));
      buf_cadd(bf, ':');
      buf_add(bf, kv_value(kv));
    }
    buf_cadd(bf, '}');
    return str_new(buf_str(bf));
  }
  
  //
  // math.c ---------------------------------
  //
  // Copyright 24-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  char *math_itos (int64_t n) {
    return str_f("%ld", n);
  }
  
  char *math_ftos (double n, int scale) {
    scale = scale < 0 ? 0 : scale > 9 ? 9 : scale;
    char *tpl = str_f("%%.%df", scale);
    char *ns = str_f(tpl, n + (n >= 0 ? 0.000000000001 : -0.000000000001));
    if (scale > 0) {
      char *p = ns;
      while (*p) {
        if (*p == ',') *p++ = '.';
        else ++p;
      }
      --p;
      while (*p == '0') --p;
      if (*p != '.') ++p;
      ns = str_left(ns, p - ns);
    }
    if (!strcmp(ns, "-0")) ns = "0";
    return ns;
  }
  
  int math_stoi (char *s) {
    return math_stol(s);
  }
  
  long math_stol (char *s) {
    s = str_trim(s);
    if (!*s)
      EXC_ILLEGAL_ARGUMENT("Bad number", "An integer", "A empty string");
  
    char *tmp;
    int64_t r = strtol(s, &tmp, 0);
    if (*tmp)
      EXC_ILLEGAL_ARGUMENT("Bad number", "A valid number", s);
  
    return r;
  }
  
  float math_stof (char *s) {
    return math_stod(s);
  }
  
  double math_stod (char *s) {
    s = str_trim(s);
    if (!*s)
      EXC_ILLEGAL_ARGUMENT("Bad number", "A double", "A empty string");
  
    struct lconv *lc = localeconv();
    int ix = str_cindex(s, '.');
    if (ix != -1) s[ix] = *lc->decimal_point;
  
    char *tmp;
    double r = strtod(s, &tmp);
    if (*tmp)
      EXC_ILLEGAL_ARGUMENT("Bad number", "A valid number", s);
  
    return r;
  }
  
  char *math_to_locale (double n, int scale) {
    scale = scale < 0 ? 0 : scale > 9 ? 9 : scale;
    char *tpl = str_f("%%'.%df", scale);
    char *ns = str_f(tpl, n);
    if (str_starts(ns, "-0")) ns = str_right(ns, 1);
    return ns;
  }
  
  double math_from_iso (char *s) {
    return math_stod(str_replace(str_replace(s, ".", ""), ",", "."));
  }
  
  double math_from_en (char *s) {
    return math_stod(str_replace(s, ",", ""));
  }
  
  int math_digits (char *s) {
    if (!*s) return FALSE;
    char *ps = s;
    char ch;
    while ((ch = *ps++)) if (ch < '0' || ch > '9') return FALSE;
    return TRUE;
  }
  
  double math_round (double n, int scale) {
    n = n >= 0 ? n + 0.00000000001 : n - 0.00000000001;
    switch (scale) {
      case 0: return round(n);
      case 1: return round (n * 10.0) / 10.0;
      case 2: return round (n * 100.0) / 100.0;
      case 3: return round (n * 1000.0) / 1000.0;
      case 4: return round (n * 10000.0) / 10000.0;
      case 5: return round (n * 100000.0) / 100000.0;
      case 6: return round (n * 1000000.0) / 1000000.0;
      case 7: return round (n * 10000000.0) / 10000000.0;
      case 8: return round (n * 100000000.0) / 100000000.0;
      case 9: return round (n * 1000000000.0) / 1000000000.0;
      default: if (scale < 0) return round(n);
               else return round (n * 1000000000.0) / 1000000000.0;
    }
  }
  
  int math_eq (double n1, double n2) {
    return math_eq_gap(n1, n2, 0.0000001);
  }
  
  int math_eq_gap (double n1, double n2, double gap) {
    gap = gap > 1 ? 1 : gap < 0.0000000001 ? 0.0000000001 : gap;
    return n1 < n2 + gap && n1 > n2 - gap;
  }
  
  double math_abs (double n) {
    return n >= 0 ? n : -n;
  }
  
  double math_pow (double base, double exp) {
    return pow(base, exp);
  }
  
  double math_sqrt (double n) {
    return sqrt(n);
  }
  
  //
  // path.c ---------------------------------
  //
  // Copyright 21-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  static char *normalize(char *path) {
    char *r = str_trim(path);
    while (str_ends(r, "/")) r = str_left(r, -1);
    return r;
  }
  
  char *path_cat (char *name1, char *name2, ...) {
    va_list args;
    char *tmp;
  
    if (!name1 || !name2)
      EXC_GENERIC("'path_cat' requieres at least 2 arguments.");
    if (!*name1) name1 = ".";
  
    Buf *bf = buf_new();
    buf_add(bf, name1);
    if (*buf_str(bf)) buf_cadd(bf, '/');
    buf_add(bf, name2);
  
    va_start(args, name2);
    tmp = va_arg(args, char *);
    while (tmp) {
      if (*buf_str(bf)) buf_cadd(bf, '/');
      buf_add(bf, tmp);
      tmp = va_arg(args, char *);
    }
    va_end(args);
  
    return str_new(buf_str(bf));
  }
  
  char *path_base (char *path) {
    path = normalize(path);
    int ix = str_last_cindex(path, '/');
    if (ix != -1) return str_right(path, ix + 1);
    return path;
  }
  
  char *path_parent (char *path) {
    char *s = normalize(path);
    if (!*s) EXC_GENERIC(str_f("'%s' has not parent directory", path));
    int ix = str_last_cindex(s, '/');
    if (ix == -1) return "";
    if (ix == 0) return "/";
    return str_left(s, ix);
  }
  
  char *path_extension (char *path) {
    path = path_base(path);
    int ix = str_last_cindex(path, '.');
    if (ix == -1) return "";
    return str_right(path, ix);
  }
  
  char *path_clean (char *path) {
    char *s = str_trim(path);
    if (!*s) return "";
    Buf *bf = buf_new();
    int isSlash = 0;
    while (*s) {
      char ch = *s++;
      if (ch == '/') {
        if (isSlash) continue;
        isSlash = 1;
        buf_cadd(bf, ch);
        continue;
      }
      isSlash = 0;
      buf_cadd(bf, ch);
    }
    s = buf_str(bf);
    if (!s[1]) return s;
    if (str_ends(s, "/")) s = str_left(s, -1);
    //<char>
    Arr *new = arr_new();
    EACH(str_csplit(s, '/'), char, part) {
      if (!strcmp(part, ".")) continue;
      if (!strcmp(part, "..")) {
        if (arr_size(new)) arr_pop(new);
        else EXC_GENERIC(str_f("Bad path for cleaning '%s'", path));
        continue;
      }
      arr_push(new, part);
    }_EACH
    s = arr_cjoin(new, '/');
    if (!*s && *path == '/')
      EXC_GENERIC(str_f("Bad path for cleaning '%s'", path));
  
    return s;
  }
  
  Opt *path_canonical (char *s) {
    char *tmp = realpath(s, NULL);
    Opt *r = tmp ? opt_some(str_new(tmp)) : opt_none();
    free(tmp);
    return r;
  }
  
  //
  // regex.c ---------------------------------
  //
  // Copyright 26-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct regex_RegexOffset {
    int begin;
    int end;
  };
  
  static RegexOffset *regexOffset_new(int begin, int end) {
    RegexOffset *this = MALLOC(RegexOffset);
    this->begin = begin;
    this->end = end;
    return this;
  }
  
  int regexOffset_begin (RegexOffset *off) {
    return off->begin;
  }
  
  int regexOffset_end (RegexOffset *off) {
    return off->end;
  }
  
  // <RegexOffset>
  static Arr *matches (regex_t *rex, char *s) {
    Arr *r = arr_new();
  
    regmatch_t match;
  
    int ix = 0;
    for (;;) {
      char *sub = str_right(s, ix);
      RegexOffset *offset = NULL;
      int rs = regexec(rex, sub, 1, &match, 0);
      if (rs == REG_ESPACE)
        EXC_GENERIC("Regular expression out of memory");
  
      if (!rs) {
        int end = ix + match.rm_eo;
        offset = regexOffset_new(ix + match.rm_so, end);
        ix = end;
      }
  
      if (offset) arr_push(r, offset);
      else break;
    }
  
    regfree(rex);
    return r;
  }
  
  // <Arr<RegexOffset>>
  Opt *regex_matches (char *rex, char *s) {
    if (!*rex)
      EXC_ILLEGAL_ARGUMENT("Bad regular expresion", "An expresion", "An empty string");
  
    regex_t exp;
    if (regcomp(&exp, rex, REG_EXTENDED)) return opt_none();
    return opt_some(matches(&exp, s));
  }
  
  // <Arr<RegexOffset>>
  Opt *regex_matches_ic (char *rex, char *s) {
    if (!*rex)
      EXC_ILLEGAL_ARGUMENT("Bad regular expresion", "An expresion", "An empty string");
  
    regex_t exp;
    if (regcomp(&exp, rex, REG_EXTENDED | REG_ICASE)) return opt_none();
    return opt_some(matches(&exp, s));
  }
  
  // matches is Arr<RegexOffset>
  static char *replace (Arr *matches, char *s, char *replacement) {
    Buf *bf = buf_new();
    int ix = 0;
    EACH(matches, RegexOffset, rg) {
      buf_add(bf, str_sub(s, ix, rg->begin));
      buf_add(bf, replacement);
      ix = rg->end;
    }_EACH
    buf_add(bf, str_right(s, ix));
    return str_new(buf_str(bf));
  }
  
  // <char>
  Opt *regex_replace (char *rex, char *s, char *replacement) {
    // <RegexOffset>
    Arr *matches = opt_get(regex_matches(rex, s));
    if (matches) return opt_some(replace(matches, s, replacement));
    return opt_none();
  }
  
  // <char>
  Opt *regex_replace_ic (char *rex, char *s, char *replacement) {
    // <RegexOffset>
    Arr *matches = opt_get(regex_matches_ic(rex, s));
    if (matches) return opt_some(replace(matches, s, replacement));
    return opt_none();
  }
  
  // matches is Arr<RegexOffset>
  static char *replacef (Arr *matches, char *s, char *(*frepl)(char *match)) {
    Buf *bf = buf_new();
    int ix = 0;
    EACH(matches, RegexOffset, rg) {
      buf_add(bf, str_sub(s, ix, rg->begin));
      buf_add(bf, frepl(str_sub(s, rg->begin, rg->end)));
      ix = rg->end;
    }_EACH
    buf_add(bf, str_right(s, ix));
    return str_new(buf_str(bf));
  }
  
  Opt *regex_replacef (char *rex, char *s, char *(*freplacement)(char *match)) {
    // <RegexOffset>
    Arr *matches = opt_get(regex_matches(rex, s));
    if (matches) return opt_some(replacef(matches, s, freplacement));
    return opt_none();
  }
  
  //
  // rs.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct rs_Rs {
    char *error;
    void *value;
  };
  
  Rs *rs_ok (void *value) {
    Rs *this = MALLOC(Rs);
    this->error = "";
    this->value = value;
    return this;
  }
  
  Rs *rs_fail (char *msg) {
    Rs *this = MALLOC(Rs);
    this->error = msg;
    this->value = NULL;
    return this;
  }
  
  void *rs_get (Rs *this) {
    return this->value;
  }
  
  char *rs_error (Rs *this) {
    return this->error;
  }
  
  char *rs_to_js (Rs *this, char *(*to)(void *e)) {
    return (*this->error)
      ? js_wa(arr_new_from(
          js_ws(this->error),
          js_wn(),
          NULL
        ))
      : js_wa(arr_new_from(
          js_ws(""),
          to(this->value),
          NULL
        ));
    ;
  }
  
  Rs *rs_from_js (char *js, void *(*from)(char *jse)) {
    // <char>
    Arr *a = js_ra(js);
    char *error = js_rs(arr_get(a, 0));
    return (*error) ? rs_fail(error) : rs_ok(from(arr_get(a, 1)));
  }
  
  //
  // str.c ---------------------------------
  //
  // Copyright 20-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  char *str_new (char *s) {
    char *r = ATOMIC(strlen(s) + 1);
    strcpy(r, s);
    return r;
  }
  
  char *str_new_c (char ch) {
    char *r = ATOMIC(2);
    *r = ch;
    r[1] = 0;
    return r;
  }
  
  int str_cmp(char *s1, char *s2) {
    return strcmp(s1, s2);
  }
  
  int str_cmp_locale(char *s1, char *s2) {
    return strcoll(s1, s2);
  }
  
  int str_greater(char *s1, char *s2) {
    return strcmp(s1, s2) > 0;
  }
  
  int str_greater_locale(char *s1, char *s2) {
    return strcoll(s1, s2) > 0;
  }
  
  int str_eq (char *str1, char *str2) {
    return !strcmp(str1, str2);
  }
  
  int str_starts (char *str, char  *substr) {
    while (*substr)
      if (*str++ != *substr++) return 0;
    return 1;
  }
  
  int str_ends (char *str, char  *substr) {
    int slen = strlen(str);
    int sublen = strlen(substr);
    return slen >= sublen && !memcmp(str + slen - sublen, substr, sublen);
  }
  
  int str_cindex (char *str, char ch) {
    int c = 0;
    char *p  = str;
    while (*p) {
      if (*p++ == ch) {
        return c;
      };
      ++c;
    }
    return -1;
  }
  
  int str_cindex_from (char *str, char ch, int from) {
    if (from >= strlen(str)) {
      return -1;
    }
    int c = from;
    char *p  = str + from;
    while (*p) {
      if (*p++ == ch) {
        return c;
      };
      ++c;
    }
    return -1;
  }
  
  int str_index(char *str, char *substr) {
    if (!*substr) {
      return 0;
    }
    int c = 0;
    int limit = strlen(str) - strlen(substr);
    char *p  = str;
    for (;;) {
      if (c > limit) {
        break;
      }
      if (str_starts(p++, substr)) {
        return c;
      };
      ++c;
    }
    return -1;
  }
  
  int str_index_from(char *str, char *substr, int from) {
    if (from >= strlen(str)) {
      return -1;
    }
  
    if (!*substr) {
      return from;
    }
    int c = from;
    int limit = strlen(str) - strlen(substr);
    char *p  = str + from;
    for (;;) {
      if (c > limit) {
        break;
      }
      if (str_starts(p++, substr)) {
        return c;
      };
      ++c;
    }
    return -1;
  }
  
  int str_last_cindex(char *str, char ch) {
    int r = -1;
    int c = 0;
    char *p  = str;
    while (*p) {
      if (*p++ == ch) {
        r = c;
      };
      ++c;
    }
    return r;
  }
  
  int str_last_index(char *str, char *substr) {
    int r = -1;
    if (!*substr) {
      return strlen(str);
    }
    int c = 0;
    int limit = strlen(str) - strlen(substr);
    char *p  = str;
    while (*p) {
      if (c > limit) {
        break;
      }
      if (str_starts(p++, substr)) {
        r = c;
      };
      ++c;
    }
    return r;
  }
  
  int str_len (char *str) {
    return strlen(str);
  }
  
  char *str_sub(char *str, int begin, int end) {
    int l = strlen(str);
    int df = -1;
    if (begin < 0) begin = l + begin;
    if (begin >= l) return "";
    if (begin < 0) begin = 0;
  
    if (end < 0) end = l + end;
    if (end > l) end = l;
    if (end <= 0) return "";
  
    df = end - begin;
  
    char *r;
    if (df < 0) return "";
  
    r = ATOMIC(df + 1);
    r[df] = 0;
    memcpy(r, str + begin, df);
    return r;
  }
  
  char *str_left(char *str, int end) {
    return str_sub(str, 0, end);
  }
  
  char *str_right(char *str, int begin) {
    return str_sub(str, begin, strlen(str));
  }
  
  char *str_ltrim(char *str) {
    unsigned char ch = *str;
    while (ch && ch <= ' ') ch = *++str;
    return str_new(str);
  }
  
  char *str_rtrim(char *str) {
    char *p = str + (strlen(str) - 1);
    while (p >= str && ((unsigned char)*p) <= ' ') {
      --p;
    }
    return str_left(str, (p - str) + 1);
  }
  
  char *str_trim(char *str) {
    unsigned char ch = *str;
    while (ch && ch <= ' ') ch = *++str;
    return str_rtrim(str);
  }
  
  // <char>
  Arr *str_csplit(char *s, char sep) {
    // <char>
    Arr *r = arr_new();
    int i = str_cindex(s, sep);
    while (i != -1) {
      char *sub = ATOMIC(i + 1);
      sub[i] = 0;
      memcpy(sub, s, i);
      arr_push(r, sub);
      s = s + i + 1;
      i = str_cindex(s, sep);
    }
    arr_push(r, str_new(s));
    return r;
  }
  
  // <char>
  Arr *str_csplit_trim(char *str, char sep) {
    // <char>
    Arr *r = str_csplit(str, sep);
    char **p = (char **)arr_begin(r);
    while (p < (char **)arr_end(r)) {
      *p = str_trim(*p);
      ++p;
    }
    return r;
  }
  
  // <char>
  Arr *str_split(char *s, char *sep) {
    // <char>
    Arr *r = arr_new();
    int len = strlen(sep);
    if (!len) {
      char *rune;
      s = str_next_rune(&rune, s);
      while (*rune) {
        arr_push(r, rune);
        s = str_next_rune(&rune, s);
      }
      return r;
    }
  
    int i = str_index(s, sep);
    while (i != -1) {
      char *sub = ATOMIC(i + 1);
      sub[i] = 0;
      memcpy(sub, s, i);
      arr_push(r, sub);
      s = s + i + len;
      i = str_index(s, sep);
    }
    arr_push(r, str_new(s));
    return r;
  }
  
  // <char>
  Arr *str_split_trim(char *str, char *sep) {
    // <char>
    Arr *r = str_split(str, sep);
    char **p = (char **)arr_begin(r);
    while (p < (char **)arr_end(r)) {
      *p = str_trim(*p);
      ++p;
    }
    return r;
  }
  
  char *str_creplace(char *s, char old, char new) {
    char *r = str_new(s);
    char *p = r;
    while (*p) {
      if (*p == old)
        *p = new;
      ++p;
    }
    return r;
  }
  
  char *str_replace(char *s, char *old, char *new) {
    if (!*old) return str_new(s);
  
    Buf *bf = buf_new();
    int len = strlen(old);
    int i = str_index(s, old);
    while (i != -1) {
      buf_add(bf, str_left(s, i));
      buf_add(bf, new);
      s = s + i + len;
      i = str_index(s, old);
    }
    buf_add(bf, s);
    return str_new(buf_str(bf));
  }
  
  char *str_vf(char *format, va_list args) {
    char *tmp;
    int len = vasprintf(&tmp, format, args);
    if (len < 0)
      exc_throw(
        exc_illegal_argument_t, "Wrong format",
        __FILE__, (char *)__func__, __LINE__);
    char *msg = ATOMIC(len + 1);
    strcpy(msg, tmp);
    free(tmp);
    return msg;
  }
  
  char *str_f(char *format, ...) {
    va_list args;
    va_start(args, format);
    char *r = str_vf(format, args);
    va_end(args);
    return r;
  }
  
  int str_runes_len(char *s) {
    unsigned char b1, b2, b3, b4;
    int r = 0;
    while (*s) {
      ++r;
      b1 = *s++;
      if (b1 < 0x80) continue;
      else if (b1 < 0xC2) return -1;
      else if (b1 < 0xE0) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) return -1;
      } else if (b1 < 0xF0) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) return -1;
        if (b1 == 0xE0 && b2 < 0xA0) return -1;
        b3 = *s++;
        if ((b3 & 0xC0) != 0x80) return -1;
      } else if (b1 < 0xF5) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) return -1;
        if (b1 == 0xF0 && b2 < 0x90) return -1;
        if (b1 == 0xF4 && b2 >= 0x90) return -1;
        b3 = *s++;
        if ((b3 & 0xC0) != 0x80) return -1;
        b4 = *s++;
        if ((b4 & 0xC0) != 0x80) return -1;
      } else return -1;
    }
    return r;
  }
  
  static char *error = "??";
  static char *replace_error = "�";
  static char *_str_next_rune(char *s) {
    unsigned char b1, b2, b3, b4;
    b1 = *s++;
    if (b1) {
      if (b1 < 0xC2) {
        return str_f("%c", b1);
      } else if (b1 < 0xE0) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) {
          return error;
        }
        return str_f("%c%c", b1, b2);
      } else if (b1 < 0xF0) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80 ||
            (b1 == 0xE0 && b2 < 0xA0)
        ) {
          return error;
        }
        b3 = *s++;
        if ((b3 & 0xC0) != 0x80) {
          return error;
        }
        return str_f("%c%c%c", b1, b2, b3);
      } else if (b1 < 0xF5) {
        b2 = *s++;
        if (((b2 & 0xC0) != 0x80) ||
            (b1 == 0xF0 && b2 < 0x90) ||
            (b1 == 0xF4 && b2 >= 0x90)
        ) {
          return error;
        }
        b3 = *s++;
        if ((b3 & 0xC0) != 0x80) {
          return error;
        }
        b4 = *s++;
        if ((b4 & 0xC0) != 0x80) {
          return error;
        }
        return str_f("%c%c%c%c", b1, b2, b3, b4);
      } else {
        return error;
      }
    }
    return "";
  }
  
  char *str_next_rune(char **rune, char *s) {
    char *r = _str_next_rune(s);
    if (r[0] == '?' && r[1] == '?') {
      *rune = str_new(replace_error);
      return s + 1;
    }
    *rune = r;
    return s + strlen(r);
  }
  
  Arr *str_runes(char *s) {
    //<char>
    Arr *r = arr_new();
    char *rune;
    while (*s) {
      s = str_next_rune(&rune, s);
      arr_push(r, rune);
    }
    return r;
  }
  
  static unsigned error2 = 65533;
  unsigned *str_to_unicode(char *s0) {
    unsigned char *s = (unsigned char *)s0;
    unsigned b1, b2, b3, b4;
    int lg = str_runes_len(s0) + 1;
    unsigned *r = ATOMIC(lg * sizeof(unsigned));
    unsigned *pr = r;
    while (*s) {
      b1 = *s++;
      if (b1 < 0x80) *pr++ = b1;
      else if (b1 < 0xC2) *pr++ = error2;
      else if (b1 < 0xE0) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) *pr++ = error2;
        *pr++ = (b1 << 6) + b2 - 0x3080;
      } else if (b1 < 0xF0) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) *pr++ = error2;
        if (b1 == 0xE0 && b2 < 0xA0) *pr++ = error2;
        b3 = *s++;
        if ((b3 & 0xC0) != 0x80) *pr++ = error2;
        *pr++ = (b1 << 12) + (b2 << 6) + b3 - 0xE2080;
      } else if (b1 < 0xF5) {
        b2 = *s++;
        if ((b2 & 0xC0) != 0x80) *pr++ = error2;
        if (b1 == 0xF0 && b2 < 0x90) *pr++ = error2;
        if (b1 == 0xF4 && b2 >= 0x90) *pr++ = error2;
        b3 = *s++;
        if ((b3 & 0xC0) != 0x80) *pr++ = error2;
        b4 = *s++;
        if ((b4 & 0xC0) != 0x80) *pr++ = error2;
        *pr++ = (b1 << 18) + (b2 << 12) + (b3 << 6) + b4 - 0x3C82080;
      } else {
        *pr++ = error2;
      }
    }
    *pr = 0;
    return r;
  }
  
  char *str_from_unicode(unsigned *u) {
    Buf *bf = buf_new();
  
    while (*u) {
      unsigned code_point = *u++;
      if (code_point < 0x80) {
        buf_cadd(bf, (unsigned char)code_point);
      } else if (code_point <= 0x7FF) {
        buf_cadd(bf, (unsigned char)(code_point >> 6) + 0xC0);
        buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);
      } else if (code_point <= 0xFFFF) {
        buf_cadd(bf, (unsigned char)(code_point >> 12) + 0xE0);
        buf_cadd(bf, (unsigned char)((code_point >> 6) & 0x3F) + 0x80);
        buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);
      } else if (code_point <= 0x10FFFF) {
        buf_cadd(bf, (unsigned char)(code_point >> 18) + 0xF0);
        buf_cadd(bf, (unsigned char)((code_point >> 12) & 0x3F) + 0x80);
        buf_cadd(bf, (unsigned char)((code_point >> 6) & 0x3F) + 0x80);
        buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);
      } else {
        buf_add(bf, replace_error);
      }
    }
  
    return str_new(buf_str(bf));
  }
  
  char *str_from_iso(char *s) {
    Buf *bf = buf_new();
    unsigned char ch = *s++;
    while (ch) {
      if(ch < 0x80) {
        buf_cadd(bf, ch);
      } else {
        buf_cadd(bf, 0xc0 | (ch & 0xc0) >> 6);
        buf_cadd(bf, 0x80 | (ch & 0x3f));
      }
      ch = *s++;
    }
    return str_new(buf_str(bf));
  }
  
  char *str_to_upper (char *s) {
    unsigned *ws = str_to_unicode(s);
    unsigned *p = ws;
    while (*p) {
      *p = (unsigned)towupper(*p);
      ++p;
    }
  
    return str_from_unicode(ws);
  }
  
  char *str_to_lower (char *s) {
    unsigned *ws = str_to_unicode(s);
    unsigned *p = ws;
    while (*p) {
      *p = (unsigned)towlower(*p);
      ++p;
    }
  
    return str_from_unicode(ws);
  }
  
  char *str_to_escape (char *s) {
    Buf *bf = buf_new();
    buf_cadd(bf, '"');
    while (*s) {
      char ch = *s++;
      if (ch == '"' || ch == '\\') {
        buf_cadd(bf, '\\');
      }
      buf_cadd(bf, ch);
    }
    buf_cadd(bf, '"');
  
    return str_new(buf_str(bf));
  }
  
  char *str_from_escape (char *s) {
    int len = strlen(s);
    if (len < 2) {
      return str_new(s);
    }
  
    ++s;
    Buf *bf = buf_new();
    while (*s) {
      char ch = *s++;
      if (ch != '\\') {
        buf_cadd(bf, ch);
      } else {
        buf_cadd(bf, *s++);
      }
    }
  
    return str_left(buf_str(bf), buf_len(bf) - 1);
  }
  
  
  //
  // sys.c ---------------------------------
  //
  // Copyright 21-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  #define _GNU_SOURCE // Need for environ
  
  static int initialized = FALSE;
  
  void sys_init(void) {
    if (initialized)
      EXC_ILLEGAL_STATE("module 'sys' already initialized");
  
    initialized = TRUE;
    setlocale(LC_ALL, "C");
  
    srand(time(0));
    exc_init();
  }
  
  // <char>
  Map *sys_environ(void) {
    //<char>
    Map *r = map_new();
    char **penv = environ;
    while (*penv) {
      // <char>
      Arr *parts = str_csplit_trim(*penv++, '=');
      map_put(r, arr_get(parts, 0), arr_get(parts, 1));
    }
    return r;
  }
  
  void sys_sleep (int millis) {
    Time end = time_now() + millis;
    struct timespec t;
    struct timespec rem;
  
    for (;;) {
      t.tv_sec = millis / 1000;
      t.tv_nsec = (millis % 1000) * 1000000;
      if (nanosleep(&t, &rem)) {
        millis = end - time_now();
        if (millis <= 0) break;
      } else {
        break;
      }
    }
  }
  
  void sys_set_locale (char *language) {
    setlocale (LC_ALL, language);
  }
  
  char *sys_get_locale (void) {
    return setlocale (LC_ALL, NULL);
  }
  
  double sys_rnd_d (void) {
    return (double)rand() / (double)RAND_MAX;
  }
  
  int sys_rnd_i (int top) {
    return (int)(sys_rnd_d() * top);
  }
  
  int sys_user_id(void) {
    return getuid();
  }
  
  char *sys_user_name() {
    char *name = opt_get(map_get(sys_environ(), "USER"));
    if (name) return name;
    return "";
  }
  
  char *sys_user_home(void) {
    char *home = opt_get(map_get(sys_environ(), "HOME"));
    if (home) return home;
    return "";
  }
  
  
  static char *cmd_error(char *command, char *error) {
    return str_f("'%s' error:\n  %s", command, error);
  }
  
  // <char>
  Rs *sys_cmd(char *command) {
    Tp *tp = sys_cmd2(command);
    return (*(char *)tp_e2(tp)) ? rs_fail(tp_e2(tp)) : rs_ok(tp_e1(tp));
  }
  
  // <<char>, <char>>
  Tp *sys_cmd2(char *command) {
    char *cmd2 = str_new(command);
    char *p = cmd2;
    while (*p) {
      char ch = *p;
      if (!(
        (ch >= 'A' && ch <= 'Z') ||
        (ch >= 'a' && ch <= 'z') ||
        (ch >= '0' && ch <= '9')
      )) *p = '_';
  
      ++p;
    }
    Tp *r;
    char *ferr = file_tmp(
      "/tmp",
      str_f("cmd_%s_", str_left(cmd2, 50))
    );
    TRY {
      char *cmd = str_f("%s 2>%s", command, ferr);
  
      FILE *fp = popen(cmd, "r");
      if (!fp) EXC_GENERIC(cmd_error(command, "Command could no be run"));
  
      Buf *bf = buf_new();
      char *line = NULL;
      size_t len = 0;
      for (;;) {
        line = NULL;
        len = 0;
        int rs = getline(&line, &len, fp);
        if (rs == -1) {
          if (feof(fp)) break;
          EXC_GENERIC(cmd_error(command, "Error while running"));
        }
        len = strlen(line);
        if (len != rs) {
          free(line);
          EXC_GENERIC(cmd_error(command, str_f(
            "getline result (%d) and line length(%d) do not match (ceros?)",
            rs, len
          )));
        }
  
        buf_add(bf, line);
        free(line);
      }
      free(line);
      pclose(fp);
  
      char *err = file_exists(ferr) ? file_read(ferr) : "";
      r = tp_new(str_new(buf_str(bf)), err);
    } CATCH (e) {
      r = tp_new("", exc_msg(e));
    }_TRY
  
    file_del(ferr);
    return r;
  }
  
  char *sys_read_line (void) {
    char *s = malloc(150);
    size_t n = 150;
    if (getline(&s, &n, stdin) == -1) {
      free(s); // correct
      EXC_IO("Fail reading on console");
    }
    char *r = str_left(s, -1);
    free(s);  // correct
    return r;
  }
  
  
  //
  // tcp.c ---------------------------------
  //
  // Copyright 23-Jan-2023 ºDeme
  // GNU General Public License - V3 <http://www.gnu.org/licenses/>
  
  
  struct tcp_TcpServer {
    int id;
  };
  
  struct tcp_TcpConn {
    int id;
  };
  
  TcpServer *tcp_server (int port, int conns) {
    TcpServer *this = MALLOC(TcpServer);
  
    struct sockaddr_in server;
    int id = socket(AF_INET , SOCK_STREAM , 0);
    if (id == -1)
      EXC_IO("Could not create socket");
  
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(port);
  
    if(bind(id,(struct sockaddr *)&server , sizeof(server)) < 0)
      EXC_IO("bind failed. Error");
  
    listen(id, conns);
  
    this->id = id;
  
    return this;
  }
  
  // <TcpConn>
  Rs *tcp_accept (TcpServer *sv) {
    TcpConn *r = MALLOC(TcpConn);
  
    struct sockaddr_in client;
    int c = sizeof(struct sockaddr_in);
    int id = accept(sv->id, (struct sockaddr *)&client, (socklen_t*)&c);
    if (id < 0)
      return rs_fail("accept failed");
  
    r->id = id;
    return rs_ok(r);
  }
  
  // <Bytes>
  Rs *tcp_read (TcpConn *conn, int len, int seconds) {
    fd_set set;
    struct timeval timeout;
    FD_ZERO (&set);
    FD_SET (conn->id, &set);
    timeout.tv_sec = seconds;
    timeout.tv_usec = 0;
  
    int rsel;
    for (;;) {
      rsel = select (FD_SETSIZE, &set, NULL, NULL, &timeout);
      if (rsel < 0 && errno == EINTR) continue;
      break;
    }
    if (rsel < 0)
      return rs_fail(str_f(
        "Fail reading on connection (select): %s", strerror(errno)
      ));
    if (rsel == 0)
      return rs_fail("Time out");
  
    unsigned char bs[len];
    int rlen;
    for (;;) {
      rlen = (int)read(conn->id, bs, len);
      if (rlen < 0 && errno == EINTR) continue;
      break;
    }
    if (rlen < 0) {
      close(conn->id);
      return rs_fail(str_f(
        "Fail reading on connection (recv): %s", strerror(errno)
      ));
    }
  
    int tt = rlen;
    if (!memcmp("POST ", bs, 5)) {
      unsigned char *pbs = bs;
      int ix = -1;
      int ibody = -1;
      for (int i = 0; i < 5000; ++i, ++pbs) {
        if (!memcmp("Content-Length: ", pbs, 16)) {
          ix = i + 16;
        } else if (!memcmp("\r\n\r\n", pbs, 4)) {
          ibody = i + 4;
        }
      }
      if (ix != -1 && ibody != -1) {
        char sn[9];
        memcpy(sn, bs + ix, 8);
        sn[8] = 0;
        int post_len = atoi(sn) + ibody;
        if (post_len > len)
          return rs_fail(str_f(
            "Post request length (%d) > maximum (%d", post_len, len
          ));
  
        while (tt < post_len) {
          for (;;) {
            rlen = (int)read(conn->id, bs + tt, len - tt);
            if (rlen < 0 && errno == EINTR) continue;
            break;
          }
          if (rlen < 0) {
            close(conn->id);
            return rs_fail(str_f(
              "Fail reading on connection (recv): %s", strerror(errno)
            ));
          }
          if (rlen == 0)
            return rs_fail("Incomplete POST request");
          tt += rlen;
        }
      }
    }
  
    Bytes *r = bytes_new();
    bytes_add_bytes(r, bs, tt);
    return rs_ok(r);
  }
  
  char *tcp_write (TcpConn *conn, Bytes *bs) {
    int rs;
    for (;;) {
      rs = send(conn->id, bytes_bs(bs), bytes_len(bs), 0);
      if (rs == -1 && errno == EINTR) continue;
      break;
    }
    if (rs == -1) {
      close(conn->id);
      return str_f("Fail sending on connection: %s", strerror(errno));
    }
    fsync(conn->id);
    return "";
  }
  
  // <TcpConn>
  Rs *tcp_dial (char *sv, int port) {
    struct sockaddr_in server;
    int id = socket(AF_INET , SOCK_STREAM , 0);
    if (id == -1) return rs_fail("Could not create socket");
    int oldflags = fcntl (id, F_GETFL, 0);
    if (oldflags == -1) return rs_fail("Could not create socket");
    if (fcntl (id, F_SETFL, oldflags) == -1)
      return rs_fail("Could not create socket");
  
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    if (!inet_aton(sv, &server.sin_addr)) {
      struct hostent *he;
      if ((he = gethostbyname(sv)) == NULL)
        return rs_fail(str_f("Host '%s' not found", sv));
      server.sin_addr = *(struct in_addr *) he->h_addr;
    }
  
    if (connect(id , (struct sockaddr *)&server , sizeof(server)) < 0)
      return rs_fail(str_f("Fail connection with '%s'", sv));
  
    TcpConn *r = MALLOC(TcpConn);
    r->id = id;
    return rs_ok(r);
  }
  
  void tcp_close_server (TcpServer *sv) {
    close(sv->id);
  }
  
  void tcp_close_conn (TcpConn *conn) {
    close(conn->id);
  }
  
  
// INTERFACE ----------------------------------------


// -------------------------------------
//02-built_in
// -------------------------------------

void ___built_jump (int reference) {
Exc *exc = exc_get();
longjmp(*((jmp_buf *)arr_pop(exc->buf)), reference);
}
char *___built_mpath(char *module_id) {
char *data = file_read(path_cat(__sys_compilerRoot().s, "index.tb", NULL));
Arr *tb = js_ra(data);
EACH(tb, char, e) {
Arr *fs = js_ra(e);
if (!strcmp(js_rs(arr_get(fs, 1)), module_id))
return js_rs(arr_get(fs, 0));
}_EACH
return "???";
}
char *___built_mpos(char *module_id, int ln) {
return str_f("%s:%d:", ___built_mpath(module_id), ln);
}
Val ___built_divi(Val pos, Val n1, Val n2) {
if (n2.i == 0) ___built_throw(pos, (Val)"Division by 0");
return (Val) (n1.i / n2.i);
}
Val ___built_divf(Val pos, Val n1, Val n2) {
if (math_eq(n2.f, 0)) ___built_throw(pos, (Val)"Division by 0");
return (Val) (n1.f / n2.f);
}
Val ___built_eq (Val type, Val value1, Val value2) {
char *t = __arr_get((Val)"", type, (Val)0).s;
if (*t == 'b') return (Val)(value1.b == value2.b);
if (*t == 'i') return (Val)(value1.i == value2.i);
if (*t == 'f') return (Val)(math_eq(value1.f, value2.f));
if (*t == 's') return (Val)(!strcmp(value1.s, value2.s));
if (*t == 'a') {
if (__arr_size(value1).i != __arr_size(value2).i) return (Val)FALSE;
Val atp = __arr_get((Val)"", __arr_get((Val)"", type, (Val)1), (Val)0);
Varr *a1 = value1.a;
Varr *a2 = value2.a;
Val *e1 = a1->begin;
Val *e2 = a2->begin;
Val *end = a1->end;
while (e1 < end) {
if (!___built_eq(atp, *e1++, *e2++).b) return (Val)FALSE;
}
return (Val)TRUE;
}
if (*t == 'd') {
if (__arr_size(value1).i != __arr_size(value2).i) return (Val)FALSE;
Val dtp = __arr_get((Val)"", __arr_get((Val)"", type, (Val)1), (Val)0);
Varr *a = value1.a;
Val *e = a->begin;
Val *end = a->end;
while (e < end) {
Varr *kv = (*e++).a;
Val rs = __dic_get(value2, kv->begin[0]);
if (
!__arr_size(rs).i |
!___built_eq(dtp, kv->begin[1], rs.a->begin[0]).b
) return (Val)FALSE;
}
return (Val)TRUE;
}
if (*t == 't') {
Varr *atp = __arr_get((Val)"", type, (Val)1).a;
Val *etp = atp->begin;
Val *endtp = atp->end;
Varr *a1 = value1.a;
Varr *a2 = value2.a;
Val *e1 = a1->begin;
Val *e2 = a2->begin;
while (etp < endtp) {
if (!___built_eq(*etp++, *e1++, *e2++).b) return (Val)FALSE;
}
return (Val)TRUE;
}
return (Val)(value1.o == value2.o);
}
Val ___built_to_str_trace (Val type, Val value) {
char *t = __arr_get((Val)"", type, (Val)0).s;
return (*t == 's')
? __js_ws(value)
: ___built_to_str(type, value)
;
}
Val ___built_to_str (Val type, Val value) {
char *t = __arr_get((Val)"", type, (Val)0).s;
if (*t == 'b') return value.b ? (Val)"true" : (Val)"false";
if (*t == 'i') return __math_itos(value);
if (*t == 'f') {
char *r = math_ftos(value.f, 9);
if (str_cindex(r, '.') == -1) r = str_f("%s.0", r);
return (Val)r;
}
if (*t == 's') return value;
if (*t == 'a') {
Val atp = __arr_get((Val)"", __arr_get((Val)"", type, (Val)1), (Val)0);
Arr *bf = arr_new(); // [s.]
Varr *a = value.a;
Val *e = a->begin;
Val *end = a->end;
while (e < end) {
arr_push(bf, ___built_to_str_trace(atp, *e++).s);
}
return (Val)str_f("[%s]", arr_join(bf, ","));
}
if (*t == 'd') {
Val dtp = __arr_get((Val)"", (__arr_get((Val)"", type, (Val)1)), (Val)0);
Arr *bf = arr_new(); // [s.]
Varr *a = value.a;
Val *e = a->begin;
Val *end = a->end;
while (e < end) {
Varr *a2 = e++->a;
Val *e2 = a2->begin;
char *key = js_ws((*e2++).s);
char *value = ___built_to_str_trace(dtp, *e2).s;
arr_push(bf, str_f("%s:%s", key, value));
}
return (Val)str_f("{%s}", arr_join(bf, ","));
}
if (*t == 't') {
Arr *bf = arr_new(); // [s.]
Varr *atp = __arr_get((Val)"", type, (Val)1).a;
Val *etp = atp->begin;
Val *endtp = atp->end;
Varr *a = value.a;
Val *e = a->begin;
while (etp < endtp) {
arr_push(bf, ___built_to_str_trace(*etp++, *e++).s);
}
return (Val)str_f("[. %s]", arr_join(bf, ","));
}
return (Val)str_f("%s(%ld)", t, (long)value.o);
}
void ___built_throw (Val pos, Val msg) {
Exc *exc = exc_get();
void *array[30];
size_t size;
char **strings;
size = backtrace(array, 30);
strings = backtrace_symbols(array, size);
char *path = path_cat(__sys_compilerRoot().s, "compilationDb", NULL);
Arr *stack = arr_new();
RANGE0(i, size) {
char *e = strings[i];
int ix1 = str_last_cindex(e, ')');
if (ix1 == -1) continue;
e = str_left(e, ix1);
ix1 = str_cindex(e, '(');
if (ix1 == -1) continue;
e = str_right(e, ix1 + 1);
ix1 = str_cindex(e, '_');
if (ix1 == -1) continue;
ix1 = str_cindex_from(e, '_', ix1 + 1);
if (ix1 == -1) continue;
int ix2 = str_cindex_from(e, '_', ix1 + 1);
if (ix2 == -1) {
if (str_starts(str_right(e, ix1), "_main+")) ix2 = ix1 + 5;
else continue;
}
char *mdId = str_left(e, ix1);
char *fn = str_sub(e, ix1 + 1, ix2);
char *mdPath = path_cat(path, str_f("%s.mod", mdId), NULL);
if (!file_exists(mdPath)) continue;
Arr *tb = js_ra(file_read(mdPath));
char *fpath = js_rs(arr_get(tb, 0));
if (!strcmp(fn, "main")) {
arr_push(stack, str_f("  %s:[main]", fpath));
continue;
}
Arr *fn_tb = js_ra(arr_get(tb, 3));
int n = -1;
EACH(fn_tb, char, e) {
Arr *fields = js_ra(e);
if (!strcmp(js_rs(arr_get(fields, 1)), fn)) {
n = js_ri(arr_get(fields, 0));
break;
}
}_EACH
if (n != -1) arr_push(stack, str_f("  %s:%d:", fpath, n));
}_RANGE
free(strings);
exc->stack = stack;
exc->msg = str_f("%s %s", pos.s, msg.s);
exc->type = "";
longjmp(*((jmp_buf *)arr_pop(exc->buf)), 1);
}
void ___built_trace (Val isComplete, Val fpos, Val type, Val value) {
char *r = ___built_to_str_trace(type, value).s;
if (!(isComplete.b)) r = arr_join(arr_take(str_runes(r), 50), "");
puts(str_f("%s %s", fpos.s, r));
}


// -------------------------------------
//arr
// -------------------------------------

Val __arr_all (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
int r = TRUE;
while (p < end) {
Val v = *p++;
r = r && (((Val (*)(Val))fn.o)(v)).b;
}
return (Val)r;
}
Val __arr_any (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
int r = FALSE;
while (p < end) {
Val v = *p++;
r = r || (((Val (*)(Val))fn.o)(v)).b;
}
return (Val)r;
}
void __arr_clear (Val a) {
a.a->end = a.a->begin;
}
void __arr_cat (Val a, Val a2) {
int64_t other_size = __arr_size(a2).i;
if (other_size) {
int64_t this_size = __arr_size(a).i;
int64_t this_buffer = a.a->end_bf - a.a->begin;
if (this_size + other_size >= this_buffer){
int64_t new_buffer = this_buffer + other_size + 15;
a.a->begin = GC_REALLOC(a.a->begin, new_buffer * sizeof(Val));
a.a->end = a.a->begin + this_size;
a.a->end_bf = a.a->begin + new_buffer;
}
Val *s = a2.a->begin;
Val *s_end = a2.a->end;
Val *t = a.a->end;
while (s < s_end) *t++ = *s++;
a.a->end = t;
}
}
Val __arr_cat2 (Val a, Val a2) {
Val r = __arr_copy(a);
__arr_cat(r, a2);
return r;
}
Val __arr_copy (Val a) {
Varr *this = a.a;
int64_t size = this->end - this->begin;
int64_t buffer = this->end_bf - this->begin;
Varr *r = MALLOC(Varr);
Val *begin = GC_MALLOC(buffer * sizeof(Val));
memcpy(begin, this->begin, size * sizeof(Val));
r->begin = begin;
r->end = begin + size;
r->end_bf = begin + buffer;
return (Val)r;
}
Val __arr_drop (Val a, Val n) {
if (n.i < 0) return __arr_copy(a);
if (n.i >= __arr_size(a).i) return __arr_new();
Val r = __arr_new();
Val *p = a.a->begin + n.i;
Val *end = a.a->end;
while (p < end) __arr_push(r, *p++);
return r;
}
Val __arr_dropWhile (Val a, Val fn) {
Val r = __arr_new();
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
if (!(((Val (*)(Val))fn.o)(*p)).b) break;
++p;
}
while (p < end) __arr_push(r, *p++);
return r;
}
Val __arr_duplicates (Val a, Val fn) {
Val r = __arr_new();
Val dup = __arr_new();
Val *ap = a.a->begin;
Val *aend = a.a->end;
while (ap < aend) {
Val e = *ap++;
Val *rp = r.a->begin;
Val *rend = r.a->end;
int missing = TRUE;
while (rp < rend) {
Val e2 = *rp++;
if ((((Val (*)(Val,Val))fn.o)(e, e2)).b) {
missing = FALSE;
Val *dp = dup.a->begin;
Val *dend = dup.a->end;
int missing2 = TRUE;
while (dp < dend) {
Val e2 = *dp++;
if ((((Val (*)(Val,Val))fn.o)(e, e2)).b) {
missing2 = FALSE;
break;
}
}
if (missing2) __arr_push(dup, e);
break;
}
}
if (missing) __arr_push(r, e);
}
return __arr_new_from_carr((Val)2, (Val[]){r, dup});
}
void __arr_each (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) ((void (*)(Val))fn.o)(*p++);
}
void __arr_eachIx (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
int64_t i = 0;
while (p < end) ((void (*)(Val,Val))fn.o)(*p++, ((Val)i++));
}
Val __arr_filter (Val a, Val fn) {
Val r = __arr_new();
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
Val e = *p++;
if ((((Val (*)(Val))fn.o)(e)).b) __arr_push(r, e);
}
return (Val)r;
}
void __arr_filterIn (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
Val *new_end = p;
while (p < end) {
Val e = *p++;
if ((((Val (*)(Val))fn.o)(e)).b) *new_end++ = e;
}
a.a->end = new_end;
}
Val __arr_find (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
Val e = *p++;
if ((((Val (*)(Val))fn.o)(e)).b)
return __arr_new_from_carr((Val)1, (Val[]){e});
}
return __arr_new();
}
Val __arr_fromIter (Val it) {
Val a = __arr_new();
while (__iter_hasNext(it).b) __arr_push(a, __iter_next(it));
return a;
}
Val __arr_from_sarr (Arr *a) {
Val r = __arr_new();
EACH(a, char, el) {
__arr_push(r, (Val)el);
}_EACH
return r;
}
Val __arr_get (Val pos, Val a, Val ix) {
int64_t sz = __arr_size(a).i;
int64_t i = ix.i;
if (i < 0 || i >= sz)
___built_throw(pos, (Val)str_f("Index %d out of [0,%d]", i, sz - 1));
return a.a->begin[i];
}
Val __arr_index (Val a, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
int64_t i = 0;
while (p < end) {
if ((((Val (*)(Val))fn.o)(*p++)).b) return (Val)i;
++i;
}
return (Val)(int64_t)-1;
}
void __arr_insert (Val pos, Val a, Val ix, Val e) {
int64_t size = __arr_size(a).i;
if (ix.i < 0 || ix.i > size)
___built_throw(pos, (Val)str_f("index %d out of [0,%d]", ix.i, size));
__arr_push(a, e);
Val *p = a.a->end;
Val *pix = a.a->begin + ix.i;
while (p > pix) {
*p = *(p - 1);
--p;
}
*p = e;
}
void __arr_insertArr (Val pos, Val a, Val ix, Val other) {
__arr_insertRange(pos, a, ix, other, (Val)0, __arr_size(other));
}
void __arr_insertRange (Val pos, Val this, Val ix, Val other, Val begin, Val end) {
int64_t this_len = __arr_size(this).i;
if (ix.i < 0 || ix.i > this_len)
___built_throw(pos, (Val)str_f("index %d out of [0,%d]", ix.i, this_len));
int64_t other_size = __arr_size(other).i;
if (end.i < begin.i)
___built_throw(pos, (Val)str_f("end(%d) < begin(%d)", end.i, begin.i));
if (begin.i < 0)
___built_throw(pos, (Val)str_f("begin(%d) < 0", begin.i));
if (end.i > other_size)
___built_throw(pos, (Val)str_f("end(%d) > size(%d)", end.i, other_size));
int64_t other_len = end.i - begin.i;
if (!other_len) return;
int64_t new_len = this_len + other_len;
int64_t new_size = new_len + 15;
Val *new_begin = GC_MALLOC(new_size * sizeof(Val));
memcpy(new_begin, this.a->begin, sizeof(Val) * ix.i);
memcpy(new_begin + ix.i, other.a->begin + begin.i, sizeof(Val) * other_len);
memcpy(
new_begin + (ix.i + other_len),
this.a->begin + ix.i,
sizeof(Val) * (__arr_size(this).i - ix.i)
);
this.a->begin = new_begin;
this.a->end = new_begin + new_len;
this.a->end_bf = new_begin + new_size;
}
Val __arr_join(Val a, Val sep) {
Buf *bf = buf_new();
int first = 1;
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
if (first) {
first = 0;
} else {
buf_add(bf, sep.s);
}
buf_add(bf, (*p++).s);
}
return (Val)str_new(buf_str(bf));
}
Val __arr_map(Val a, Val fn) {
Val r = __arr_new();
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) __arr_push(r, ((Val (*)(Val))fn.o)(*p++));
return r;
}
Val __arr_new (void) {
Varr *this = MALLOC(Varr);
this->begin = GC_MALLOC(15 * sizeof(Val));
this->end = this->begin;
this->end_bf = this->begin + 15;
return (Val)this;
}
Val __arr_new_fill (Val el, Val n) {
int64_t size = n.i < 0 ? 0 : n.i;
int64_t bf_size = size + 15;
Varr *this = MALLOC(Varr);
this->begin = GC_MALLOC(bf_size * sizeof(Val));
this->end = this->begin + size;
this->end_bf = this->begin + bf_size;
Val *p = this->begin;
Val *end = this->end;
while (p < end) *p++ = el;
return (Val)this;
}
Val __arr_new_from_carr (Val n, Val *els) {
Val r = __arr_new();
REPEAT(n.i) {
__arr_push(r, *els++);
}_REPEAT
return r;
}
Val __arr_peek (Val pos, Val a) {
int64_t size = __arr_size(a).i;
if (size == 0) ___built_throw(pos, (Val)"Array is empty");
return *(a.a->end - 1);
}
Val __arr_pop (Val pos, Val a) {
int64_t size = __arr_size(a).i;
if (size == 0) ___built_throw(pos, (Val)"Array is empty");
return *(a.a->end-- - 1);
}
void __arr_push (Val a, Val el) {
Varr *this = a.a;
if (this->end == this->end_bf) {
int size = this->end_bf - this->begin;
int new_size = size + size;
this->begin = GC_REALLOC(this->begin, new_size * sizeof(Val));
this->end = this->begin + size;
this->end_bf = this->begin + new_size;
}
*this->end++ = el;
}
Val __arr_reduce (Val a, Val seed, Val fn) {
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) seed = ((Val (*)(Val,Val))fn.o)(seed, *p++);
return seed;
}
Val __arr_remove (Val pos, Val a, Val ix) {
int64_t sz = __arr_size(a).i;
int64_t i = ix.i;
if (i < 0 || i >= sz)
___built_throw(pos, (Val)str_f("index %d out of [0,%d]", i, sz - 1));
Val *p = a.a->begin + ix.i;
Val r = *p;
Val *p1 = p + 1;
Val *end = a.a->end--;
while (p1 < end) *p++ = *p1++;
return r;
}
Val __arr_removeRange (Val pos, Val a, Val begin, Val end) {
int64_t sz = __arr_size(a).i;
int64_t b = begin.i;
int64_t e = end.i;
if (b < 0 || b >= sz)
___built_throw(pos, (Val)str_f("begin index %d out of [0,%d]", b, sz - 1));
if (e < b || e > sz)
___built_throw(pos, (Val)str_f("end index %d out of [%d,%d]", e, b, sz));
int64_t len = e - b;
Val r = __arr_take(__arr_drop(a, begin), (Val)len);
Val *p = a.a->begin + b;
Val *p1 = a.a->begin + e;
Val *pend = a.a->end;
a.a->end -= len;
while (p1 < pend) *p++ = *p1++;
return r;
}
Val __arr_reverse (Val a) {
Val r = __arr_copy(a);
__arr_reverseIn(r);
return r;
}
void __arr_reverseIn (Val a) {
int64_t sz = __arr_size(a).i;
Val *p = a.a->begin;
Val *end = a.a->end - 1;
Val tmp;
for (int i = 0; i < sz / 2; ++i) {
tmp = *p;
*p++ = *end;
*end-- = tmp;
}
}
void __arr_set (Val pos, Val a, Val ix, Val el) {
int64_t sz = __arr_size(a).i;
int64_t i = ix.i;
if (i < 0 || i >= sz)
___built_throw(pos, (Val)str_f("index %d out of [0,%d]", i, sz - 1));
a.a->begin[i] = el;
}
void __arr_setArr (Val pos, Val a, Val ix, Val other) {
__arr_setRange(pos, a, ix, other, (Val)0, __arr_size(other));
}
void __arr_setRange (Val pos, Val this, Val ix, Val other, Val begin, Val end) {
int64_t this_len = __arr_size(this).i;
int64_t other_size = __arr_size(other).i;
if (ix.i < 0 || ix.i > this_len - other_size)
___built_throw(
pos, (Val)str_f("index %d out of [0,%d]", ix.i, this_len - other_size)
);
if (end.i < begin.i)
___built_throw(pos, (Val)str_f("end(%d) < begin(%d)", end.i, begin.i));
if (begin.i < 0)
___built_throw(pos, (Val)str_f("begin(%d) < 0", begin.i));
if (end.i > other_size)
___built_throw(pos, (Val)str_f("end(%d) > size(%d)", end.i, other_size));
int64_t other_len = end.i - begin.i;
if (!other_len) return;
Val *target = this.a->begin + ix.i;
Val *source = other.a->begin + begin.i;
memcpy(target, source, sizeof(Val *) * other_len);
}
Val __arr_shift (Val pos, Val a) {
int64_t size = __arr_size(a).i;
if (size == 0) ___built_throw(pos, (Val)"Array is empty");
Val *p = a.a->begin;
Val r = *p;
Val *p1 = p + 1;
Val *end = a.a->end--;
while (p1 < end) *p++ = *p1++;
return r;
}
void __arr_shuffle (Val a) {
int64_t size = __arr_size(a).i;
Val *begin = a.a->begin;
Val *p = a.a->end - 1;
Val *pix, tmp;
while (p > begin) {
pix = begin + sys_rnd_i(size--);
tmp = *p;
*p-- = *pix;
*pix = tmp;
}
}
Val __arr_size (Val a) {
return (Val)(a.a->end - a.a->begin);
}
void __arr_sort (Val a, Val fn) {
Val (*less0)(Val, Val) = (Val (*)(Val, Val))fn.o;
int less (Val e1, Val e2) {
return less0(e1, e2).b;
}
void sort(Val *a, int64_t size) {
if (size < 2) {
return;
}
if (size == 2) {
if (less(a[1], a[0])) { Val tmp = a[0]; a[0] = a[1]; a[1] = tmp; }
return;
}
if (size == 3) {
if (less(a[1], a[0])) { Val tmp = a[0]; a[0] = a[1]; a[1] = tmp; }
if (less(a[2], a[0])) { Val tmp = a[0]; a[0] = a[2]; a[2] = tmp; }
if (less(a[2], a[1])) { Val tmp = a[1]; a[1] = a[2]; a[2] = tmp; }
}
int64_t mid1 = size >> 1;
int64_t mid2 = size - mid1;
Val a1[mid1];
Val a2[mid2];
Val *pa = a;
Val *pa1 = a1;
Val *pa2 = a2;
for (int64_t i = 0; i < mid1; ++i) *pa1++ = *pa++;
for (int64_t i = 0; i < mid2; ++i) *pa2++ = *pa++;
sort(a1, mid1);
sort(a2, mid2);
pa = a;
pa1 = a1;
Val *pa1_end = a1 + mid1;
pa2 = a2;
Val *pa2_end = a2 + mid2;
for(;;) {
if (pa1 == pa1_end) {
while (pa2 < pa2_end) *pa++ = *pa2++;
break;
}
if (pa2 == pa2_end) {
while (pa1 < pa1_end) *pa++ = *pa1++;
break;
}
if (less(*pa2, *pa1)) *pa++ = *pa2++;
else *pa++ = *pa1++;
}
}
sort(a.a->begin, __arr_size(a).i);
}
Val __arr_sub (Val a, Val begin, Val end) {
if (begin.i < 0) begin = (Val)(__arr_size(a).i + begin.i);
if (end.i < 0) end = (Val)(__arr_size(a).i + end.i);
return __arr_drop(__arr_take(a, end), begin);
}
Val __arr_sub0 (Val a, Val begin) {
if (begin.i < 0) begin = (Val)(__arr_size(a).i + begin.i);
return __arr_drop(a, begin);
}
Val __arr_take (Val a, Val n) {
if (n.i > __arr_size(a).i) return __arr_copy(a);
Val r = __arr_new();
Val *p = a.a->begin;
for (int64_t i = 0; i < n.i; ++i) __arr_push(r, *p++);
return r;
}
Val __arr_takeWhile (Val a, Val fn) {
Val r = __arr_new();
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
if (!(((Val (*)(Val))fn.o)(*p)).b) break;
__arr_push(r, *p++);
}
return r;
}
Val __arr_toIter_next (Val obj) {
Val *p = obj.a->begin;
Val a = *p;
int64_t sz = (p+1)->i;
int64_t c = (p+2)->i;
if (c < sz) {
Val r = *(a.a->begin+c);
*(p+2) = (Val)(c + 1);
return __arr_new_from_carr((Val)1, (Val[]){r});
}
return __arr_new();
}
Val __arr_toIter (Val a) {
return __iter_new(__arr_new_from_carr((Val)2, (Val[]){
__arr_new_from_carr((Val)3, (Val[]){a, __arr_size(a), (Val)0}),
(Val)(void *)__arr_toIter_next
}));
}
Val __arr_to_js (Val a, Val fn) {
return __js_wa(__arr_map(a, fn));
}
Arr *__arr_to_sarr (Val a) {
Arr *r = arr_new();
Varr *va = a.a;
Val *p = va->begin;
Val *end = va->end;
while (p < end) arr_push(r, (*p++).s);
return r;
}
void __arr_unshift (Val a, Val e) {
__arr_push(a, e);
Val *p = a.a->end;
Val *pix = a.a->begin;
while (p > pix) {
*p = *(p - 1);
--p;
}
*p = e;
}
Val __arr_unzip (Val a) {
Val a1 = __arr_new();
Val a2 = __arr_new();
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
Val t = *p++;
__arr_push(a1, *(t.a->begin));
__arr_push(a2, *(t.a->begin + 1));
}
return __arr_new_from_carr((Val)2, (Val[]){a1, a2});
}
Val __arr_unzip3 (Val a) {
Val a1 = __arr_new();
Val a2 = __arr_new();
Val a3 = __arr_new();
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) {
Val t = *p++;
__arr_push(a1, *(t.a->begin));
__arr_push(a2, *(t.a->begin + 1));
__arr_push(a3, *(t.a->begin + 2));
}
return __arr_new_from_carr((Val)3, (Val[]){a1, a2, a3});
}
Val __arr_zip (Val a1, Val a2) {
Val r = __arr_new();
int64_t sz = __arr_size(a1).i < __arr_size(a2).i
? __arr_size(a1).i
: __arr_size(a2).i
;
int64_t c = 0;
Val *p1 = a1.a->begin;
Val *p2 = a2.a->begin;
while (c < sz) {
__arr_push(r, __arr_new_from_carr((Val)2, (Val[]){*p1++, *p2++}));
++c;
}
return r;
}
Val __arr_zip3 (Val a1, Val a2, Val a3) {
Val r = __arr_new();
int64_t sz = __arr_size(a1).i < __arr_size(a2).i
? __arr_size(a1).i
: __arr_size(a2).i
;
sz = sz < __arr_size(a3).i
? sz
: __arr_size(a2).i < __arr_size(a3).i
? __arr_size(a2).i
: __arr_size(a3).i
;
int64_t c = 0;
Val *p1 = a1.a->begin;
Val *p2 = a2.a->begin;
Val *p3 = a3.a->begin;
while (c < sz) {
__arr_push(r, __arr_new_from_carr((Val)3, (Val[]){*p1++, *p2++, *p3++}));
++c;
}
return r;
}


// -------------------------------------
//b64
// -------------------------------------

Val __b64_decode (char *pos, Val b64) {
char *r;
TRY {
r = b64_decode(b64.s);
} CATCH(e) {
EXC_KUTT(str_f("%s %s", pos, e));
}_TRY
return (Val) r;
}
Val __b64_encode (Val s) {
return (Val)b64_encode(s.s);
}


// -------------------------------------
//bytes
// -------------------------------------

Val __bytes_add (Val bs1, Val bs2) {
bytes_add((Bytes *)bs1.o, (Bytes *)bs2.o);
return bs1;
}
Val __bytes_drop (Val bts, Val begin) {
Bytes *bs = (Bytes *)bts.o;
int64_t ix = begin.i;
int64_t sz = bytes_len(bs);
Bytes *bs2 = sz > ix
? ix <= 0
? bytes_from_bytes(bytes_bs(bs), sz)
: bytes_from_bytes(bytes_bs(bs) + ix, sz - ix)
: bytes_new()
;
return (Val)(void *)bs2;
}
Val __bytes_fromArr (Val a) {
int64_t sz = __arr_size(a).i;
Bytes *bs = bytes_new_bf(sz);
unsigned char *pu = bytes_bs(bs);
Val *p = a.a->begin;
Val *end = a.a->end;
while (p < end) *pu++ = (unsigned char)(*p++).i;
return (Val)(void *)bs;
}
Val __bytes_fromStr (Val str) {
return (Val)(void *)bytes_from_str(str.s);
}
Val __bytes_get (Val pos, Val bs, Val ix) {
int64_t sz = __bytes_size(bs).i;
int64_t i = ix.i;
if (i < 0 || i >= sz)
___built_throw(pos, (Val)str_f("Index %d out of [0,%d]", i, sz - 1));
return (Val)(int64_t)(bytes_bs((Bytes *)bs.o)[ix.i]);
}
Val __bytes_new (Val size) {
int64_t bf = size.i;
if (bf < 0) bf = 0;
Bytes *bs = bytes_new_bf(bf);
unsigned char *p = bytes_bs(bs);
while (bf) {
*p++ = 0;
--bf;
}
return (Val)(void *)bs;
}
void __bytes_set (Val pos, Val bs, Val ix, Val byte) {
int64_t sz = __bytes_size(bs).i;
int64_t i = ix.i;
if (i < 0 || i >= sz)
___built_throw(pos, (Val)str_f("Index %d out of [0,%d]", i, sz - 1));
bytes_bs((Bytes *)bs.o)[ix.i] = (unsigned char)byte.i;
}
Val __bytes_size (Val bs) {
return (Val)(int64_t)bytes_len((Bytes *)bs.o);
}
Val __bytes_take (Val bts, Val end) {
Bytes *bs = (Bytes *)bts.o;
int64_t ix = end.i;
int64_t sz = bytes_len(bs);
Bytes *bs2 = ix <= 0
? bytes_new()
: ix >= sz
? bytes_from_bytes(bytes_bs(bs), sz)
: bytes_from_bytes(bytes_bs(bs), ix)
;
return (Val)(void *)bs2;
}
Val __bytes_toArr (Val bts) {
Bytes *bs = (Bytes *)bts.o;
int sz = bytes_len(bs);
Val a = __arr_new();
unsigned char *p = bytes_bs(bs);
while (sz) {
__arr_push(a, (Val)(int64_t)*p++);
--sz;
}
return a;
}
Val __bytes_toStr (Val bs) {
return (Val)bytes_to_str((Bytes *)bs.o);
}


// -------------------------------------
//dic
// -------------------------------------

Val __dic_from_smap (Map *m) {
Val r = __arr_new();
EACH(m, Kv, el) {
Val e = __arr_new();
__arr_push(e, (Val)kv_key(el));
__arr_push(e, (Val)((char *)kv_value(el)));
__arr_push(r, e);
}_EACH
return r;
}
Val __dic_get(Val d, Val key) {
Varr *a = d.a;
Val *p = a->begin;
Val *end = a->end;
while (p < end) {
Varr *kv = (*p++).a;
if (!strcmp(kv->begin[0].s, key.s)) return __rs_some(kv->begin[1]);
}
return  __arr_new();
}
Val __dic_new_from_carr (Val n, Val *els) {
Val r = __arr_new();
REPEAT(n.i) {
Varr *kv = (*els++).a;
__dic_put(r, kv->begin[0], kv->begin[1]);
}_REPEAT
return r;
}
void __dic_put(Val d, Val key, Val value) {
int new = TRUE;
char *k = key.s;
Varr *a = d.a;
Val *p = a->begin;
Val *end = a->end;
while (p < end) {
Varr *kv = (*p++).a;
if (!strcmp(k, kv->begin[0].s)) {
kv->begin[1] = value;
new = FALSE;
break;
}
}
if (new) __arr_push(d, __arr_new_from_carr((Val)2, (Val[]){key, value}));
}
Val __dic_to_js (Val d, Val (*fn)(Val)) {
Map *r = map_new();
Varr *va = d.a;
Val *p = va->begin;
Val *end = va->end;
while (p < end) {
Varr *kv = (*p++).a;
arr_push((Arr *)r, kv_new((kv->begin[0]).s, fn(kv->begin[1]).s));
}
return __js_wo(__dic_from_smap(r));
}
Map *__dic_to_smap (Val a) {
Map *r = map_new();
Varr *va = a.a;
Val *p = va->begin;
Val *end = va->end;
while (p < end) {
Varr *kv = (*p++).a;
arr_push((Arr *)r, kv_new((kv->begin[0]).s, (kv->begin[1]).s));
}
return r;
}


// -------------------------------------
//iter
// -------------------------------------

Val __iter_all (Val it, Val fn) {
int r = TRUE;
while (__iter_hasNext(it).b) {
Val v = __iter_next(it);
r = r && (((Val (*)(Val))fn.o)(v)).b;
}
return (Val)r;
}
Val __iter_any (Val it, Val fn) {
int r = FALSE;
while (__iter_hasNext(it).b) {
Val v = __iter_next(it);
r = r || (((Val (*)(Val))fn.o)(v)).b;
}
return (Val)r;
}
Val __iter_cat_next (Val obj) {
Val *p = obj.a->begin;
if (p->b) {
Val it = *(p+1);
if (__iter_hasNext(it).b) return __rs_some(__iter_next(it));
*p = (Val) FALSE;
}
Val it = *(p+2);
return (__iter_hasNext(it).b) ? __rs_some(__iter_next(it)) : __arr_new();
}
Val __iter_cat (Val it1, Val it2) {
Val obj = __arr_new_from_carr((Val)3, (Val[]){(Val)TRUE, it1, it2});
return __iter_new_aux(obj, __iter_cat_next);
}
Val __iter_count (Val it) {
int64_t c = 0;
while (__iter_hasNext(it).b) {
__iter_next(it);
++c;
}
return (Val)c;
}
Val __iter_drop (Val it, Val n) {
int64_t nv = n.i;
int64_t c = 0;
for(;;) {
if (c >= nv || !__iter_hasNext(it).b) break;
++c;
__iter_next(it);
}
return it;
}
Val __iter_empty_next (Val fake) {
return __arr_new();
}
Val __iter_empty (Val fake) {
return __iter_new_aux(fake, __iter_empty_next);
}
Val __iter_hasNext (Val it) {
return (Val)(__arr_size(*(it.a->begin)).i > 0);
}
Val __iter_new (Val tuple) {
Val *p = tuple.a->begin;
Val a = ((Val (*)(Val))(*(p+1)).o)(*p);
return __arr_new_from_carr((Val)2, (Val[]){a, tuple});
}
Val __iter_new_aux (Val obj, Val (*fn) (Val)) {
return __iter_new(__arr_new_from_carr((Val)2, (Val[]){
obj, (Val)(void *)fn
}));
}
Val __iter_next (Val it) {
Val r = *(it.a->begin);
if (__arr_size(r).i == 0)
___built_throw((Val)"Built-in", (Val)"Iterator is empty");
Val tuple = *(it.a->begin + 1);
Val *p = tuple.a->begin;
*(it.a->begin) = ((Val (*)(Val))(*(p+1)).o)(*p);
return *r.a->begin;
}
Val __iter_range_next (Val obj) {
Val *p = obj.a->begin;
int64_t begin = p->i;
int64_t end = (p+1)->i;
int withStep = (p+3)->i;
if (withStep) {
int64_t step = (p+2)->i;
if (step > 0) {
if (begin <= end) {
*p = (Val)(begin + step);
return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});
}
} else {
if (begin >= end) {
*p = (Val)(begin + step);
return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});
}
}
} else {
if (begin < end) {
*p = (Val)(begin + 1);
return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});
}
}
return __arr_new();
}
Val __iter_range (Val pos, Val vs) {
Val obj = __arr_new();
Val *p = vs.a->begin;
int64_t sz = __arr_size(vs).i;
if (sz == 1) {
__arr_push(obj, (Val) 0);
__arr_push(obj, *p);
__arr_push(obj, (Val) 1);
__arr_push(obj, (Val) 0);
} else if (sz == 2) {
__arr_push(obj, *p++);
__arr_push(obj, *p);
__arr_push(obj, (Val) 1);
__arr_push(obj, (Val) 0);
} else {
__arr_push(obj, *p++);
__arr_push(obj, *p++);
if (p->i == 0)
___built_throw(pos, (Val)"Range step is 0");
__arr_push(obj, *p);
__arr_push(obj, (Val) 1);
}
return __iter_new_aux(obj, __iter_range_next);
}
Val __iter_take_next (Val obj) {
Val *p = obj.a->begin;
Val it = *p;
int64_t n = (p+1)->i;
int64_t c = (p+2)->i;
if (c < n) {
if (__iter_hasNext(it).b) {
*(p+2) = (Val)(c + 1);
return __rs_some(__iter_next(it));
}
*(p+2) = *(p+1);
}
return __arr_new();
}
Val __iter_take (Val it, Val n){
return __iter_new_aux(
__arr_new_from_carr((Val)3, (Val[]){it, n, (Val)0}),
__iter_take_next
);
}
Val __iter_unary_next (Val obj) {
if (__arr_size(obj).i) {
Val r = __arr_copy(obj);
__arr_clear(obj);
return r;
}
return __arr_new();
}
Val __iter_unary (Val value) {
return __iter_new_aux(__rs_some(value), __iter_unary_next);
}


// -------------------------------------
//js
// -------------------------------------

Val __js_is_null (Val json) {
return (Val)js_is_null(json.s);
}
Val __js_rb (Val json) {
return (Val)js_rb(json.s);
}
Val __js_ri (Val json) {
return (Val)js_rl(json.s);
}
Val __js_rf (Val json) {
return (Val)js_rd(json.s);
}
Val __js_rs (Val json) {
return (Val)js_rs(json.s);
}
Val __js_ra (Val json) {
return __arr_from_sarr(js_ra(json.s));
}
Val __js_ro (Val json) {
return __dic_from_smap(js_ro(json.s));
}
Val __js_wn(void) {
return (Val)js_wn();
}
Val __js_wb(Val value) {
return (Val)js_wb(value.b);
}
Val __js_wi(Val n) {
return (Val)math_itos(n.i);
}
Val __js_wf(Val n) {
return (Val)math_ftos(n.f, 9);
}
Val __js_ws(Val s) {
return (Val)js_ws(s.s);
}
Val __js_wa(Val a) {
return (Val)js_wa(__arr_to_sarr(a));
}
Val __js_wo(Val m) {
return (Val)js_wo(__dic_to_smap(m));
}


// -------------------------------------
//math
// -------------------------------------

Val __math_abs (Val n) {
return (Val)math_abs(n.f);
}
Val __math_acos (Val n) {
return (Val)acos(n.f);
}
Val __math_acosh (Val n) {
return (Val)acosh(n.f);
}
Val __math_asin (Val n) {
return (Val)asin(n.f);
}
Val __math_asinh (Val n) {
return (Val)asinh(n.f);
}
Val __math_atan (Val n) {
return (Val)atan(n.f);
}
Val __math_atanh (Val n) {
return (Val)atanh(n.f);
}
Val __math_ceil (Val n) {
return (Val)ceil(n.f);
}
Val __math_cos (Val n) {
return (Val)cos(n.f);
}
Val __math_cosh (Val n) {
return (Val)cosh(n.f);
}
Val __math_e (void) {
return (Val)M_E;
}
Val __math_eq (Val n1, Val n2, Val gap) {
return (Val)math_eq_gap(n1.f, n2.f, gap.f);
}
Val __math_exp (Val n) {
return (Val)exp(n.f);
}
Val __math_exp2 (Val n) {
return (Val)exp2(n.f);
}
Val __math_floor (Val n) {
return (Val)floor(n.f);
}
Val __math_fromEn (Val s) {
return __math_stof((Val)str_replace(s.s, ",", ""));
}
Val __math_fromHex (Val s) {
char *n = str_trim(s.s);
if (!*n) return __arr_new();
char *tmp;
int64_t r = strtol(n, &tmp, 16);
if (*tmp) return __arr_new();
return __rs_some((Val)r);
}
Val __math_fromIso (Val s) {
return __math_stof((Val)str_replace(str_replace(s.s, ".", ""), ",", "."));
}
Val __math_ftoi (Val n) {
return (Val)(int64_t)(n.f);
}
Val __math_ftos (Val n) {
return (Val)math_ftos(n.f, 9);
}
Val __math_ftos2 (Val n, Val dec) {
return (Val)math_ftos(n.f, dec.i);
}
Val __math_isDigits (Val n) {
return (Val)math_digits(n.s);
}
Val __math_itof (Val n) {
return (Val)(double)(n.i);
}
Val __math_itoh (Val n) {
return (Val)str_f("%x", n.i);
}
Val __math_itos (Val n) {
return (Val)math_itos(n.i);
}
Val __math_log (Val n) {
return (Val)log(n.f);
}
Val __math_log10 (Val n) {
return (Val)log10(n.f);
}
Val __math_log2 (Val n) {
return (Val)log2(n.f);
}
Val __math_max (Val n1, Val n2) {
return n1.f >= n2.f ? n1 : n2;
}
Val __math_maxFloat (void) {
return (Val)DBL_MAX;
}
Val __math_maxInt (void) {
return (Val)(int64_t)
(sizeof(int64_t) == sizeof(long long int) ? LLONG_MAX : LONG_MAX);
}
Val __math_min (Val n1, Val n2) {
return n1.f <= n2.f ? n1 : n2;
}
Val __math_minInt (void) {
return (Val)(int64_t)
(sizeof(int64_t) == sizeof(long long int) ? LLONG_MIN : LONG_MIN);
}
Val __math_pi (void) {
return (Val)M_PI;
}
Val __math_pow (Val base, Val exp) {
return (Val)pow(base.f, exp.f);
}
Val __math_pow10 (Val exp) {
int64_t n = exp.i;
double r = 1;
double mul = n > 0 ? 10 : 0.1;
n = n >= 0 ? n : -n;
REPEAT(n) {
r *= mul;
}_REPEAT
return (Val)r;
}
Val __math_rnd (void) {
return (Val)((double)rand() / (double)RAND_MAX);
}
Val __math_rndi (Val top) {
return (Val)(int64_t)(((double)rand() / (double)RAND_MAX) * top.i);
}
Val __math_round (Val n, Val dec) {
return (Val)math_round(n.f, dec.i);
}
Val __math_sin (Val n) {
return (Val)sin(n.f);
}
Val __math_sinh (Val n) {
return (Val)sinh(n.f);
}
Val __math_sqrt (Val n) {
return (Val)sqrt(n.f);
}
Val __math_stof (Val s) {
char *n = str_trim(s.s);
if (!*n) return __arr_new();
struct lconv *lc = localeconv();
int ix = str_cindex(n, '.');
if (ix != -1) n[ix] = *lc->decimal_point;
char *tmp;
double r = strtod(n, &tmp);
if (*tmp) return __arr_new();
return __rs_some((Val)r);
}
Val __math_stoi (Val s) {
char *n = str_trim(s.s);
if (!*n) return __arr_new();
char *tmp;
int64_t r = strtol(n, &tmp, 10);
if (*tmp) return __arr_new();
return __rs_some((Val)r);
}
Val __math_tan (Val n) {
return (Val)tan(n.f);
}
Val __math_tanh (Val n) {
return (Val)tanh(n.f);
}
Val __math_trunc (Val n) {
return (Val)trunc(n.f);
}


// -------------------------------------
//rs
// -------------------------------------

Val __rs_some (Val v) {
return __arr_new_from_carr((Val) 1, (Val[]){v});
}
Val __rs_ok (Val v) {
return __arr_new_from_carr((Val) 2, (Val[]){v, (Val)""});
}
Val __rs_error (Val v) {
return __arr_new_from_carr((Val) 2, (Val[]){v, v});
}
Val __rs_get (Val rs) {
return rs.a->begin[0];
}
Val __rs_eget (Val rs) {
return rs.a->begin[1];
}


// -------------------------------------
//str
// -------------------------------------

Val __str_cmp (Val s1, Val s2) {
return (Val)(int64_t)strcoll(s1.s, s2.s);
}
Val __str_ends (Val str, Val substr) {
return (Val)str_ends(str.s, substr.s);
}
Val __str_fmt (Val pos, Val format, Val args) {
char *fmt = format.s;
Varr *as = args.a;
Arr *pts = str_split(fmt, "%v");
if (arr_size(pts) != __arr_size(args).i + 1)
___built_throw(pos, (Val)str_f(
"Wrong arguments number (expected %d, fund %s)",
arr_size(pts) - 1, __arr_size(args).i
));
Val rs = __arr_new();
void **ps = arr_begin(pts);
__arr_push(rs, (Val)str_replace((char *) *ps++, "%%", "%"));
Val *pas = as->begin;
Val *pend = as->end;
while (pas < pend) {
__arr_push(rs, *pas++);
__arr_push(rs, (Val)str_replace((char *) *ps++, "%%", "%"));
}
return __arr_join(rs, (Val)"");
}
Val __str_fromIso (Val s) {
return (Val)str_from_iso(s.s);
}
Val __str_fromRunes (Val a) {
return __arr_join(a, (Val)"");
}
Val __str_fromUtf16 (Val codepoints) {
int64_t sz = __arr_size(codepoints).i;
unsigned *u = ATOMIC(sizeof(unsigned) * (sz + 1));
Val *p = codepoints.a->begin;
Val *end = codepoints.a->end;
unsigned *pu = u;
while (p < end) *pu++ = (unsigned)(*p++).i;
*pu = 0;
return (Val)str_from_unicode(u);
};
Val __str_get(Val pos, Val s, Val ix) {
if (ix.i < 0 || ix.i >= strlen(s.s))
___built_throw(pos, (Val)str_f("Index %d out of [0,%d]", ix.i, strlen(s.s) - 1));
return (Val)str_new_c(s.s[ix.i]);
}
Val __str_index(Val str, Val substr) {
return (Val)(int64_t)str_index(str.s, substr.s);
}
Val __str_indexFrom (Val str, Val substr, Val start) {
return (Val)(int64_t)str_index_from(str.s, substr.s, start.i);
}
Val __str_lastIndex (Val str, Val substr) {
return (Val)(int64_t)str_last_index(str.s, substr.s);
}
Val __str_left (Val str, Val end) {
Val r = __str_toRunes(str);
int64_t sz = __arr_size(r).i;
end = end.i < 0 ? (Val)(sz + end.i) : end;
return __arr_join(__arr_take(r, end), (Val)"");
}
Val __str_left_slice(Val str, Val begin) {
return (Val)str_left(str.s, begin.i);
}
Val __str_len (Val str) {
return (Val)(int64_t)strlen(str.s);
}
Val __str_ltrim (Val str) {
return (Val)str_ltrim(str.s);
}
Val __str_replace (Val s, Val old, Val new) {
return (Val)str_replace(s.s, old.s, new.s);
}
Val __str_right (Val str, Val begin) {
Val r = __str_toRunes(str);
int64_t sz = __arr_size(r).i;
begin = begin.i < 0 ? (Val)(sz + begin.i) : begin;
return __arr_join(__arr_drop(r, begin), (Val)"");
}
Val __str_right_slice(Val str, Val begin) {
return (Val)str_right(str.s, begin.i);
}
Val __str_rtrim (Val str) {
return (Val)str_rtrim(str.s);
}
Val __str_split (Val str, Val sep) {
char *s = str.s;
char *ssep = sep.s;
Val r = __arr_new();
int len = strlen(ssep);
if (!len) {
char *rune;
s = str_next_rune(&rune, s);
while (*rune) {
__arr_push(r, (Val)rune);
s = str_next_rune(&rune, s);
}
return r;
}
int i = str_index(s, ssep);
while (i != -1) {
char *sub = ATOMIC(i + 1);
sub[i] = 0;
memcpy(sub, s, i);
__arr_push(r, (Val)sub);
s = s + i + len;
i = str_index(s, ssep);
}
__arr_push(r, (Val)str_new(s));
return r;
}
Val __str_splitTrim (Val str, Val sep) {
Val r = __str_split(str, sep);
Val *p = r.a->begin;
Val *end = r.a->end;
while (p < end) {
*p = __str_trim(*p);
++p;
}
return r;
}
Val __str_starts(Val str, Val substr) {
return (Val)str_starts(str.s, substr.s);
}
Val __str_sub (Val str, Val begin, Val end) {
Val r = __str_toRunes(str);
int64_t sz = __arr_size(r).i;
begin = begin.i < 0 ? (Val)(sz + begin.i) : begin;
end = end.i < 0 ? (Val)(sz + end.i) : end;
return __arr_join(__arr_drop(__arr_take(r, end), begin), (Val)"");
}
Val __str_sub_slice(Val str, Val begin, Val end) {
return (Val)str_sub(str.s, begin.i, end.i);
}
Val __str_toLower(Val s) {
return (Val)str_to_lower(s.s);
}
Val __str_toUpper(Val s) {
return (Val)str_to_upper(s.s);
}
Val __str_toRunes (Val str) {
char *s = str.s;
Val r = __arr_new();
char *rune;
s = str_next_rune(&rune, s);
while (*rune) {
__arr_push(r, (Val)rune);
s = str_next_rune(&rune, s);
}
return r;
}
Val __str_toUtf16 (Val str) {
unsigned *u = str_to_unicode(str.s);
Val a = __arr_new();
unsigned *pu = u;
while (*pu) __arr_push(a, (Val)(int64_t)*pu++);
return a;
}
Val __str_trim (Val str) {
return (Val)str_trim(str.s);
}


// -------------------------------------
//sys
// -------------------------------------

static Val __sys_compiler_root_v = (Val) "";
static void __sys_shandler (int sig) {
___built_throw((Val)"buil-in", (Val)"Arithmetic exception");
}
static void __sys_sshandler (int sig) {
___built_throw((Val)"buil-in", (Val)"Segmentation violation");
}
void __sys_init(Val compiler_root) {
sys_init();
signal (SIGFPE, __sys_shandler);
signal (SIGSEGV, __sys_sshandler);
__sys_compiler_root_v = compiler_root;
}
Val __sys_compilerRoot (void) {
return __sys_compiler_root_v;
}
Val __sys_getLocale (void) {
return (Val)sys_get_locale();
}
void __sys_setLocale (Val charset) {
return sys_set_locale(charset.s);
}


  """
;
